{"meta":{"title":"小英英的博客","subtitle":null,"description":"越努力越幸运~","author":"小英英","url":"https://wangcherry.github.io/blog"},"pages":[],"posts":[{"title":"严选工程化实践","slug":"严选工程化实践","date":"2019-12-24T09:30:50.000Z","updated":"2019-12-27T02:47:17.838Z","comments":true,"path":"2019/12/24/严选工程化实践/","link":"","permalink":"https://wangcherry.github.io/blog/2019/12/24/严选工程化实践/","excerpt":"","text":"今年在组里由 angular 技术栈转变成 react 技术栈的大背景下，我们急需一套完善的工程化方案来帮助技术栈落地。在通过确定目标、定义规范、技术调研、开发实现等一系列步骤之后，我们获得一个一套完善的工程化方案。在此做一个记录说明，记录下在实现过程中遇到的问题，希望我的解决思路可以给大家带来一点思考。 目录本文主要从以下四个点分享工程化方案： 目标定义 方案设计 后续计划 总结 目标定义作为一个工程化方案，我们最终的目标是尽可能解决项目生命周期里遇到的问题和痛点，例如： 我们团队根据大量的实践经验，总结出一套自己的规范，这一套规范包括项目规范和流程规范，那么这一套规范如何通过我们的工具落地到实际开发中呢？ 第二个是我们希望通过大家使用这个工具，完成一个提升开发效率的目标，这个提效包括初始化好一个项目，并且这个项目的dev环境，数据mock，build打包等一系列流程都是完成好的。 第三个目标是解决开发过程中的一个痛点。例如有些资源可以通过封装组件的形式资源共享，但是还有一部分资源大部分情况都还是copy的方式进行复用，例如A、B两个系统有一个相似的列表页，那么这个列表模块复用能不能通过工具完成呢？ 第四个目标也是解决一个痛点问题，例如我们资源/项目需要升级了，大多情况是资源开发者出一个升级文档，然后升级的人按照文档一步步修改。这是很重复的一份工作，因为假如你手上有十个项目，你就需要把相同的事情做十遍，那这一步重复的工作我们能不能提到工具里来完成呢？ 方案设计基于以上的目标，我们来看一下整个工程化的方案设计。 首先，我们看一下整个方案的架构图： 架构图我们可以看到整个架构图分为四层： 底层依赖最底层依赖了规范、webpack、schematics、node，它是上次架构的基石。规范这里包括了项目规范和流程规范，是我们整套方案需要遵守的一些约定；schematics 引入主要是为了解决上面说到的文件处理那块的痛点问题，后面会详细讲到。 插件封装层这一层主要是对上层需要实现的功能做一个划分，然后通过插件的形式实现。例如：我们将一系列模板做一个抽离，然后这一系列模板在初始化的时候需要做的模板处理放到 init 插件中完成；我们的开发编译阶段需要的 webpack 和server脚本我们就可以放在 @sharkr/scripts 插件中完成；前面说到的资源复用和资源升级问题，我把它叫做文件处理相关的，就抽离在 @sharkr/schematics-cli 插件中完成；还有一部分插件就是比较共用的方法抽离了 util 插件，方便共享； 统一命令层第三层是统一命令层，这一层做的事情就是，最终对用户暴露一个统一的工具 @sharkr/cli ，在 cli 里去规范我们常用的一些命令，当然这些命令的具体实现都是调的下一层的插件。最后，将这些命令应用到项目开发周期中去。 项目生命周期项目生命周期，这是我抽象出来的一个概念，就是说我们项目从初始化，到开发（或者是后期迭代），再到CICD的这么一个周期。我们可以看到下一层的命令大多都可以对应到项目生命周期中，例如： init 完成项目初始化 dev 可以使你快速的进入开发 add 可以给你的项目增加一个资源 generate 可以执行资源里定义的命令 update 帮助快速升级资源 test 对开发过程中的代码做一个测试 build 在CI阶段可以帮助完成编译打包 通过这整个架构我们可以看到，我们的工具可以介入到项目生命周期里的所有环节，那么这些环节有的一些问题和痛点，我们也可以通过我们的工具去尽量解决。下面我将会从项目生命周期的角度讲解一些我们工程化的一个具体方案。 项目初始化首先，我们项目初始化过程需要解决的一个问题就是：帮助规范落地。 我把规范分为项目规范和流程规范，流程规范我们上面也介绍了，通过我们的工具做了一个约束，那么项目规范怎么在初始化的时候落地呢？ 我们的做法是，将这部分规范落地到模板当中，用户通过 @sharkr/cli 去 init 项目，选择合适的模板，完成模板处理，然后就完成了一个项目初始化。 这里我们提到选择合适模板，完成模板处理，这是一个什么东西呢？ init 插件我们每个团队都会有一些常用的业务场景，例如我们B端，会维护好几个模板，纯 web 的、带 node server 的、应用于微应用的，那么这一系列我们作为一个集合，配套的我们会出一个相应的 init 插件，这个插件可以完成我这部分模板的初始化处理。假如说其他团队也有自己的模板，那么同样的，他也可以提供模板配套的 init 插件供 cli 调用。 这是插件的一个好处，可以方便扩展自定义的部分，但是它也带来了一个小问题，例如，这部分插件不是很稳定，可能经常需要更新，它的频繁更新会给用户带来影响。 插件更新我们先看一下我们最初采用的插件更新机制，如下图： 用户执行 sr init myapp，调用 @sharkr/cli @sharkr/cli 检查init插件版本 发现版本不是最新的，提示用户 update @sharkr/cli 用户全局update @sharkr/cli 再次执行 sr init myapp, 调用 @sharkr/cli @sharkr/cli 调用最新的 init 处理 这种方式需要用户经常手动更新，不是很友好，所以在后来方案设计时，改用了采用 npx 的方式调用 init 插件 npx 是 npm5.2 版本中新增的命令，它能临时下载一个模块并且运行它，运行之后再删除这个模块 用户执行 sr init myapp，调用 @sharkr/cli @sharkr/cli 使用 npx 调用最新的 init 插件处理 通过方案二，我们可以看到使用 npx 的方式调用插件，可以使用户在任何时候使用 init 命令都能调用最新的 init 插件完成项目初始化。 说完了项目初始化，我们再来看一下开发/迭代过程中会遇到哪些问题和痛点。 开发/迭代完成项目初始化进入开发阶段，我们遇到的第一个问题就是 dev 环境，例如我们需要 webpack 配置编译代码，需要一个本地 server，需要一个数据转发等，这一部分很好解决，我们通过 @sharkr/scripts 提供 webpack 和 server 脚本，在模板里集成调用，用 koa 起一个本地服务，koa 中间件完成转发等。这个很好解决，反而是前面说到的资源复用和资源/项目升级，我们怎么解决呢。下面我们重点解释一下。 资源复用我把资源分为两类，一类是有固定输入输出，可抽离的，例如时间控件，下拉列表等；还有一类是无固定输入输出，不可抽离，但是又具有某些共性的，例如B端常见的列表页、详情页，这一部分资源没有一个很好的复用方式。 对于第一类资源，我们可以采用封装组件的形式完成资源共享： 对于第二类资源，我们以前的做法基本是 Ctrl+c、Ctrl+v 来复用，这种做法不够高级，还效率不高，所以我们 cli 提供的第二种做法，那就是将代码模板抽离到一个 schematic 包里，然后通过 @sharkr/cli 来安装这个包，并且执行里面的 schematic。 资源/项目升级同样的，假如我们的项目或者是资源需要升级，就需要在项目中升级依赖，可能还需要修改配置、甚至调整目录结构、修改api调用等。这种升级我们以前的做法是，出一份升级文档，升级者按照文档一步步修改项目完成升级。假如有几十个项目，就需要几十个人做相同的事几十遍，这无疑是一个大的人力消耗，我们作为一个提效工具，就是需要将这部分重复的工作通过代码完成。 把升级文档里做的事情编写成 schematic 包 通过 @sharkr/cli 来安装这个包，并且执行里面的 schematic 这么一看，好像很简单，不管是资源复用，还是项目升级，都写成 schematic 包就好了，那么schematic到底是什么呢？ schematicsschematics是什么Schematics 是 @angular-devkit 中的一个功能，可以将变化应用到项目中，总的来说是一个基于模板的支持复杂逻辑的代码生成器。 Schematics 是 Angular 生态系统的一部分，但是它的核心实现都是单独发包的，可以理解为任何的文件处理它都能实现，即使我们的技术栈是 react。 Schematics 执行核心的本质就是在维护一个非常大的 Observable 数据流，这里的数据就是文件树。 更多schematics知识&gt;&gt; schematics能做什么schematics 能完成所有基于文件的改动，比如创建一个组件、添加配置项、将框架添加到现有项目，或者更新你的代码来修复更新依赖时带来的 break change。 schematics 与 node 脚本的区别可能有同学看到这里有点疑惑了，我说的 schematics 好像用 node 的脚本写写也能实现。是的，schematics 确实是需要在 node 容器里运行，所以 node 里所有的包它都能结合使用。 但是，schematics 跟单纯的 node 脚本相比，具有两大优势： schematics 描述了一个虚拟文件系统 schematics 内置了很多任务 例如我们要对文件进行修改，使用fs模块，修改直接作用到物理文件，一旦中间某些文件发生错误，再回退修改就比较麻烦了。而 schematics 描述了一个虚拟的文件系统，它包含实际的物理文件目录和修改暂存区两部分，暂存区记录修改，只有当全部确认以后，这些修改才会合并到物理文件上。 schematics 还内置了很多任务，例如你添加了一个模块，需要自己写很多代码，但是 schematics 就提供了 NodePackageInstallTask 直接帮你完成。而且它还会帮你检查依赖的依赖，是不是需要一并安装。还有例如RepositoryInitializerTask git初始化、TslintFixTask tslint处理等内置任务。 schematics 不妨碍你使用 node 包，它只是对文件处理做了增强。 schematics 封装既然 schematics 处理文件很友好，而且刚好能解决我们的问题，于是我们就引入了 schematics 完成文件处理，并对它做了一层封装。 下面我们来看下，开发和使用一个 schematics 包需要做点什么呢？ 首先，对于开发者来说，需要做以下三步： 根据 schematics 规范开发一个 schematics 包 定义配置项（可选） 定义 schema 命令 其次，对于用户来说，需要做以下三步： 使用 @sharkr/cli 调用 schematics 包 输入配置（可选） 完成项目修改 那么 @sharkr/cli 做了什么了？ @sharkr/cli 调用 @sharkr/schematics 插件 schematics 插件解析出自定义配置项，生成用户会话 根据用户会话拿到 option，传入 option 调用 Rule 函数 修改文件放到暂存区 确认修改后更新物理文件 这里 Rule 函数是需要开发者实现的，任何你想写成文档的都能通过代码方式写在这个 Rule 函数里。 schematics 实践下面我们来看一个实际的例子：前段时间我们的项目都需要完成服务上云，为了实现上云，我们需要调整下CI脚本，还要往项目里放一些环境配置文件，涉及到多处文件修改和增加，所以我们写了一个 @sharkr/ng-cloud-add 的 schematics 包达到快速改造项目的目的。以下是效果： 核心代码写起来跟写文档类似： 以上就讲完了我们在开发/迭代过程中遇到的问题和解决方案，最后我们再看一下CICD阶段做了什么 CI这部分跟 dev 环境类似，也是提供 webpack 配置、build 脚本、还约束了 build 打包后的目录规范。 价值与后续计划价值通过介绍以上的一些方案设计，可以发现这套工具可以让开发更专注业务本身，初始化项目之后就可以直接进入开发；重复的Ctrl+c、Ctrl+v可以通过 schematics 完成，省去重复的人力成本；项目/资源升级可以更加快速推进；规范和文档沉淀到工具中供使用，非常有利于规范的遵守。 后续计划当然，我们目前还存在一些不足，这些不足将在后续的计划中得到完善，例如： 编写 schematics 包需要对 schematics 有一些了解，那么后续我们将会提供包的基础模板和常用方法，让大家开发更便捷。 放在 schematics 包里的资源没有一个很好的展示平台，那么后续我们将会对接正在开发的物料平台，让资源更容易被共享。 总结本篇分享主要从四个方面对工程化实践做了一个阐述： 开发规范的落地依赖模板收敛项目规范，cli 工具收敛流程规范的方式，并在初始化项目时将模板应用于实际项目场景。 cli 工具的扩展依赖于插件式，对于自定义的部分提供相应插件即可扩展，而插件的更新依赖npx调用的方式，解决用户需要频繁更新问题。 我们方便快速初始化项目，提供完备的 dev 环境和 build 脚本等提升了我们的开发效率。 资源复用和资源/项目升级统称为文件处理部分，这部分我们是借用了 angular 里的 schematics 功能完成的。在这部分我们还讲了什么是 schematics 以及它在 cli 里做了什么。 以上。","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"},{"name":"cli","slug":"cli","permalink":"https://wangcherry.github.io/blog/tags/cli/"},{"name":"方案设计","slug":"方案设计","permalink":"https://wangcherry.github.io/blog/tags/方案设计/"}]},{"title":"大量数据列表不卡顿的秘密","slug":"大量数据列表不卡顿的秘密","date":"2019-12-14T07:33:12.000Z","updated":"2019-12-14T07:34:35.935Z","comments":true,"path":"2019/12/14/大量数据列表不卡顿的秘密/","link":"","permalink":"https://wangcherry.github.io/blog/2019/12/14/大量数据列表不卡顿的秘密/","excerpt":"","text":"待写","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wangcherry.github.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://wangcherry.github.io/blog/tags/css/"},{"name":"js","slug":"js","permalink":"https://wangcherry.github.io/blog/tags/js/"}]},{"title":"nodejs开发CLI工具","slug":"nodejs开发CLI工具","date":"2019-09-25T01:34:34.000Z","updated":"2019-09-25T15:12:39.960Z","comments":true,"path":"2019/09/25/nodejs开发CLI工具/","link":"","permalink":"https://wangcherry.github.io/blog/2019/09/25/nodejs开发CLI工具/","excerpt":"","text":"在没有@vue/cli、create-react-app、@angular/cli这样子的脚手架时你是否遇到过一个文件一个文件的去拷贝老项目的配置文件？在开始使用脚手架后是否发现当前的脚手架不能完全贴合实际的业务场景？最近，我们组由angular框架转换成react框架，开发了一套完整的cli工具。写下这篇文章作为一个记录，希望大家看到后都能实现一个属于自己的脚手架工具。 CLI（command-line interface，命令行界面）是指可在用户提示符下键入可执行指令的界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。 准备工作主要分为以下几步： 新建一个项目并初始化package.json 开发前准备 获取参数 新建一个项目并初始化package.json12mkdir cli &amp; cd clinpm init 在package.json里配置命令，bin项用来指定各个内部命令对应的可执行文件的位置。这里 sr 就是我的命令了123\"bin\": &#123; \"sr\": \"./bin/index.js\"&#125; 开发前准备在bin文件夹下创建一个index.js ./bin/index.js123#!/usr/bin/env nodeconsole.log('my cli！'); 将命令链接到全局：1npm link 执行命令后，my-cli会根据package.json上的配置，sr 命令被链接到全局。更多npm link知识 这时在任何目录执行 sr 将会看到： 到这里就可以开始开发 cli 了，./bin/index.js 的更改会实时同步到全局命令的。 获取参数有了命令，那么具体子命令怎么执行呢？例如我输入 sr info 时希望能打印当前环境信息。效果如下： 首先，我们需要获取参数，因为知道是 info 命令，才能执行打印环境信息操作。那么怎么获取命令行参数呢？下面介绍用原始方法和使用模块获取命令行参数： 原始方法获取命令参数命令行参数可以用系统变量 process.argv 获取。（打印当前环境信息用 envinfo） ./bin/index.js123456789101112131415161718192021222324#!/usr/bin/env nodeconst envinfo = require('envinfo');if(process.argv[2] === 'info' ) &#123; envinfo .run( &#123; System: ['OS', 'CPU'], Binaries: ['Node', 'Yarn', 'npm'], Browsers: ['Chrome', 'Edge', 'Firefox', 'Safari'], npmPackages: ['envinfo'], npmGlobalPackages: ['@sharkr/cli'], &#125;, &#123; showNotFound: true, duplicates: true, fullTree: true, &#125; ) .then(console.log);&#125;else &#123; console.log('my cli！')&#125; 使用模块commander获取命令参数commander这个模块是node.js命令行界面的完整解决方案，不仅有着强大的参数解析功能，还提供了用户命令行输入，是cli开发的一个很好选择。 ./bin/index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env nodeconst envinfo = require('envinfo');const program = require('commander');program .version(require('../package').version) .usage('&lt;command&gt; [options]');program .command('info') .description('Print debugging information about your environment') .option('-s, --show-not-found', 'show not found package') .action((cmd) =&gt; &#123; const options = cleanArgs(cmd); console.log(options) envinfo .run( &#123; System: ['OS', 'CPU'], Binaries: ['Node', 'Yarn', 'npm'], Browsers: ['Chrome', 'Edge', 'Firefox', 'Safari'], npmPackages: ['envinfo'], npmGlobalPackages: ['@sharkr/cli', 'xxx'], &#125;, &#123; showNotFound: options.showNotFound, duplicates: true, fullTree: true, &#125; ) .then(console.log); &#125;);program.parse(process.argv);function camelize(str) &#123; return str.replace(/-(\\w)/g, (_, c) =&gt; (c ? c.toUpperCase() : ''));&#125;function cleanArgs(cmd) &#123; const args = &#123;&#125;; cmd.options.forEach(o =&gt; &#123; const key = camelize(o.long.replace(/^--/, '')); if (typeof cmd[key] !== 'function' &amp;&amp; typeof cmd[key] !== 'undefined') &#123; args[key] = cmd[key]; &#125; &#125;); return args;&#125; command：子命令 description：命令描述 option：配置项 action：命令对应要执行的方法 cleanArgs 函数将 option 处理成键值对，方便使用 program.parse(process.argv) 解析命令参数 init命令经过上面的准备工作，cli 已经可以获取命令和参数了，那么接下来就可以开始写命令对应的操作了。作为项目的脚手架，第一步当然是初始化一个项目。分为以下两步完成： 准备模板 编写init命令 准备模板我们的模板都放在 gitlab 维护，init 时从 gitlab clone，这么做主要是考虑到我们模板比较多，且前期模板不稳定，避免模板更新时需要频繁更新 cli。多个模板可以通过配置项来选择。 编写init命令以下是省去很多校验和兼容处理的一个init命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546program .command('init &lt;app-name&gt;') .description('Init a new react project') .option('-t, --type &lt;type&gt;', 'Set template type') .option('-y, --useYarn', 'Use yarn install (default use npm)') .action(async (appName, cmd) =&gt; &#123; const options = cleanArgs(cmd); // 获取代码前可以进行一些特性对话 let templateGit; if (options.type) &#123; // 虚构的git模板地址 templateGit = `git@github.com:sharkr/react-template/$&#123; options.type &#125;.git`; &#125; else &#123; const &#123; type &#125; = await inquirer.prompt([ &#123; name: 'type', type: 'list', message: `Select template type:`, choices: [ &#123; name: 'full, include server &amp; web', value: 'full' &#125;, &#123; name: 'web, only web template', value: 'web' &#125;, &#123; name: 'npm, include server &amp; web for package', value: 'npm' &#125; ], default: 'full', &#125;, ]); // 虚构的git模板地址 templateGit = `git@github.com:sharkr/react-template/$&#123;type&#125;.git`; &#125; // clone代码 execSync(`git clone $&#123;templateGit&#125; $&#123;appName&#125;`, &#123; stdio: 'ignore' &#125;); const appPath = path.resolve(appName); process.chdir(appPath); fse.removeSync(path.join(appPath, '.git')); // 这里可以对模板做一下处理 // 根据配置项install if(options.useYarn) &#123; spawn('yarn', ['install'], &#123; stdio: 'inherit' &#125;); &#125;else &#123; spawn('npm', ['install'], &#123; stdio: 'inherit' &#125;); &#125; &#125;); 执行 sr init my-app init 命令提供一个配置项 type 设置需要拉取的模板类型，我们可以执行 sr init my-app 初始化项目，没设置 type 时需要选择模板类型。执行 sr init my-app -t full 时直接拉取full模板。在实际开发中，可以根据模板的用途做更多的特性选择和处理。 小结：在命令行工具的开发过程中，使用commander、inquirer和chalk等一些npm插件，可以很好的完成命令行工具的开发，并且可以达到很棒的效果，感兴趣的话，赶快试试吧，做一款自己的命令行工具。","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"},{"name":"cli","slug":"cli","permalink":"https://wangcherry.github.io/blog/tags/cli/"}]},{"title":"nodejs实现http和https代理服务","slug":"nodejs实现http和https代理服务","date":"2019-04-30T02:22:55.000Z","updated":"2019-09-25T14:34:58.955Z","comments":true,"path":"2019/04/30/nodejs实现http和https代理服务/","link":"","permalink":"https://wangcherry.github.io/blog/2019/04/30/nodejs实现http和https代理服务/","excerpt":"","text":"http/https协议作为一个程序员，我们经常会使用到代理，例如将本地请求转到测试环境以完成联调；或将某些请求转发到指定服务器等。那么代理转发的实现原理是什么呢？下面将介绍nodejs如何实现http和https代理服务。 关于HTTP和HTTPS协议： HTTP(Hypertext Transfer Protocol，超文本传输协议) 在OSI七层模型属于应用层协议，在网络与传输层使用可靠的数据传输协议TCP/IP，HTTP协议采用明文传输信息的方式。 HTTPS (Secure Hypertext Transfer Protocol，安全超文本传输协议）是一个安全通信通道，基于HTTP开发，用于在客户端和服务器之间交换信息时采用安全套接字层(SSL)进行信息交换。通俗地讲，HTTPS是HTTP的安全版，即使用了TLS/SSL加密的HTTP协议。 http/https代理原理下面主要介绍两种代理实现，一种是“中间人”代理（《http权威指南》第六章），还有一种是隧道代理（《http权威指南》第八章） “中间人”代理MITM（中间人）代理在实际开发和测试中经常会使用。调试接口、查看HTTP请求与响应时使用的http抓包调试工具如：Fiddler、 Charles，就是基于该原理实现的。用户通过设置代理，网络请求就会通过中间人代理，再发往正式服务器。 所以我们的实现原理就是建立一个可以同时与客户端和服务端进行通信的网络服务。 中间人代理示意图（来源于《HTTP权威指南》）： HTTP客户端会向代理发送请求报文，代理服务器必须像Web服务器一样，正确的处理请求和连接，然后返回响应。同时，代理自身要向服务器发送请求，这样，其行为就必须像正确的HTTP客户端一样，要发送请求并接受响应。 那么http代理的实现方案就是： 此时的代理就是“中间人”，代理拦截到请求之后可以修改请求数据，再向服务器发起请求，获取到数据后也可以修改数据，再返回给客户端。当然，代理也可以不向服务器发起请求，而是直接返回本地的数据，那就是数据mock。 用node运行下面代码（注意需要设置开启代理）12345678910111213141516171819202122232425262728const http = require('http');const url = require('url');function request(req, res) &#123; const u = url.parse(req.url); const options = &#123; hostname : u.hostname, port : u.port || 80, path : u.path, method : req.method, headers : req.headers &#125;; const proxyReq = http.request(options, function(proxyRes) &#123; console.log('http proxy：' + options.hostname); res.writeHead(proxyRes.statusCode, proxyRes.headers); proxyRes.pipe(res); &#125;).on('error', function(e) &#123; res.end(); &#125;); req.pipe(proxyReq);&#125;const proxy = http.createServer(request);proxy.listen(8888); 隧道代理上面已经完成了HTTP代理，那么是不是将HTTP换成HTTPS就能实现HTTPS代理呢？答案是不能，首先我们来看下HTTP和HTTPS去区别： 从上图可以知道HTTPS的分层是在传输层之上建立了安全层，所有的HTTP请求都在安全层上传输。所以对于http代理，我们只需要拦截请求，就可获取到报文信息从而完成转发。但是对于https请求，我们无法获取安全层数据。更多SSL/TLS协议知识可以参考SSL/TLS协议运行机制的概述 那么我们如何转发HTTPS流量呢。方法就是在客户端和服务器之间建立一条Web隧道。Web隧道用HTTP的CONNECT方法建立起来的。 CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。这种方法不仅能代理HTTPS请求，理论上可以代理所有基于TCP协议的请求。不过HTTP流量代理会耗费一次TCP连接，所以默认HTTP流量不走隧道代理。 下图显示了CONNECT方法如何建立一条到达网关的隧道（来源于《HTTP权威指南》）： 那么隧道代理的实现方案就是： 第一步：客户端像http代理发起CONNECT请求。第二步：http代理接收到CONNECT请求后与abc.com的433端口建立tcp连接。第三步：与abc.com的433端口建立tcp连接成功，通知客户端。 隧道连接示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const http = require('http');const net = require('net');const url = require('url');function request(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end('响应内容');&#125;function connect(req, cltSocket, head) &#123; console.log('TCP连接已完成'); // 连接到原始服务器。 const srvUrl = url.parse(`http://$&#123;req.url&#125;`); const srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () =&gt; &#123; cltSocket.write('HTTP/1.1 200 Connection Established\\r\\n' + 'Proxy-agent: Node.js-Proxy\\r\\n' + '\\r\\n'); srvSocket.write(head); srvSocket.pipe(cltSocket); cltSocket.pipe(srvSocket); &#125;);&#125;// 创建 HTTP 隧道代理。const proxy = http.createServer(request);proxy.on('connect', connect);// 代理正在运行。proxy.listen(8888, '127.0.0.1', () =&gt; &#123; // 向隧道代理发出请求。 const options = &#123; port: 8888, host: '127.0.0.1', method: 'CONNECT', path: 'nodejs.cn:80' &#125;; const req = http.request(options); req.end(); req.on('connect', (res, socket, head) =&gt; &#123; console.log('已连接'); // 通过 HTTP 隧道发出请求。 socket.write('GET / HTTP/1.1\\r\\n' + 'Host: nodejs.cn:80\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n'); socket.on('data', (chunk) =&gt; &#123; console.log(chunk.toString()); &#125;); socket.on('end', () =&gt; &#123; proxy.close(); &#125;); &#125;);&#125;); 解析HTTPS请求明文信息如果我们需要将请求转发到指定目标服务器，那么就需要解析HTTPS的请求报文了。我们都知道SSL的三大功能：内容加密、身份验证和校验机制，校验机制依赖于 MAC（Message authentication code）校验机制，下面主要谈一下身份验证和内容加密。 首先，我们需要支持身份认证，才能建立安全连接，身份认证依赖于证书认证机制。域名证书 是每个支持HTTPS网站都需要有的一份证书，用于客户端验证该网站的安全性，而该证书通常是通过安全机构申请的，这个机构就是 CA（Certificate Authority，证书颁发机构）。在每台用户计算机的操作系统或浏览器中，都会维护一份受信任的CA列表，浏览器在获取到域名证书之后，会向CA根证书进行验证，包含在列表之中的证书，或者由列表中的证书签发的证书都会被客户端信任，如果验证通过则能正常收发请求。 客户端验证服务器证书示意图： 由于代理服务器并没有合法的域名证书（证书只存在真实目标服务器，无法获取到），所以我们需要在代理服务器上伪造证书，实现方案是，node生成根证书，安装并信任，在拦截到https请求时，我们利用根证书动态签发域名证书，并将证书返回给浏览器，浏览器验证证书，由于域名证书是我们信任的根证书签发的，所以会验证通过。 生成根证书：12openssl genrsa -out private.pem 2048openssl req -new -x509 -key private.pem -out public.crt -days 99999 注意运行第二条信息时，需要填写一些证书信息，我们是本地测试，Common Name 可以填写127.0.0.1。然后安装并信任即可（安装信任证书请自行百度） 最后，我们来看下代理服务器如何解析HTTPS请求报文。我们知道，SSL的内容加密功能依赖于密钥协商机制， 报文信息加密解密示意图（简化版）： 1，建立连接时，客户端发起请求；代理拦截后生成域名证书B和私钥b，并用私钥b给证书B签名；同时，代理跟服务器建立连接；服务器用私钥a给证书A签名，并返回给代理；代理将证书B返回给客户端。随后客户端随机生成主密钥M，并用证书B加密，由主密钥生成会话密钥Q；代理拦截后用私钥b解密获得主密钥M，并随机生成主密钥N，用证书A加密发往服务器，并由主密钥生成会话密钥P；服务器解密获得主密钥N。2，完成连接后，客户端用会话密钥Q加密请求；代理拦截后解密获得明文信息，再用会话密钥P加密发往服务器；服务器解密获得明文信息，返回数据； 到此，我们的代理就能解析HTTPS请求的明文信息了，也可以修改信息后发往目标服务器，从而实现HTTPS代理。 最后代理服务器可以实现各种时髦且有用的功能。它们可以改善安全性，提高性能，节省费用。代理服务器可以看到并接触到所有流过的HTTP流量，所以代理服务器可以监视流量并对其进行修改，以实现很多有用的增值Web服务。希望以上的原理介绍可以帮助到大家更好的理解代理服务。","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"},{"name":"http","slug":"http","permalink":"https://wangcherry.github.io/blog/tags/http/"}]},{"title":"barrel文件引起循环依赖","slug":"barrel文件引起循环依赖","date":"2019-04-08T06:07:48.000Z","updated":"2019-04-09T02:31:26.871Z","comments":true,"path":"2019/04/08/barrel文件引起循环依赖/","link":"","permalink":"https://wangcherry.github.io/blog/2019/04/08/barrel文件引起循环依赖/","excerpt":"","text":"在给QDC项目升级时，碰到这样一个报错。server没问题，build时报错 没有报具体错误，按照报错翻译应该是“遇到未定义的provider，通常意味着有一个循环依赖，可能是由于使用“barrel” index.ts 文件引起的”。于是我检查项目中的 provider 使用没有问题，检查了各个模块之间的依赖也没有问题，注意到项目中写了很多index.ts文件，咋一看没有什么问题，比较难发现，但是仔细看index的引用发现barrel使用时有些坑需要注意。 Barrel先介绍一下Barrel，barrel是将多个模块的导出汇总到一个模块的一种方法。barrel本身是一个模块文件，可以重新导出其他模块的选定导出。 例如有三个模块123456789101112131415161718// heroes/hero.component.tsexport class HeroComponent &#123;&#125;// heroes/hero.model.tsexport class Hero &#123;&#125;// heroes/hero.service.tsexport class HeroService &#123;&#125;// index.tsexport * from './hero.model.ts'; // re-export all of its exportsexport * from './hero.service.ts'; // re-export all of its exportsexport &#123; HeroComponent &#125; from './hero.component.ts'; // re-export the named thing// used barrelimport &#123; Hero, HeroService &#125; from '../heroes'; // index is implied// without barrelexport &#123; Hero &#125; from '../heroes/hero.model.ts';export &#123; HeroService &#125; from '../heroes/hero.service.ts'; Barrel的坑在导入同一个模块中的文件时使用barrel可以让文件看起来更清爽，但是在使用时需要注意，因为使用不当可能会引起循环依赖。在这个DQC这个项目中，依赖了@datapi/dscomponent这个包，包在本地打包没问题，但是发成npm包被项目引用后，项目打包就报上面的错误。我简化下，还原报错原因。 目录结构：|—service|—|—a.service.ts|—|—b.service.ts|—|—index.ts|—table|—|—…|—|—table.module.ts 例如如下使用1234567891011121314// a.service.tsexport class AService &#123; &#125;// index.tsexport * from './a.service.ts';export * from './b.service.ts';// table.module.tsimport &#123; AService &#125; from '../service';@NgModule(&#123; ... providers: [AService]&#125;)export class TableModule &#123; &#125; import { AService } from &#39;../service&#39;; 改为 import { AService } from &#39;../service/a.service.ts&#39;; 后问题得到解决 angular风格指南angular团队已经不推荐barrel这种写法，在风格指南已经删除相关写法。 所以删除项目中的barrel，改为具体文件导入。 参考文章Angular DI Error - EXCEPTION: Can’t resolve all parametersBarrel and Circular dependency","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]},{"title":"表格固定表头和固定列","slug":"表格固定表头和固定列","date":"2019-01-12T08:26:52.000Z","updated":"2019-01-15T01:47:31.611Z","comments":true,"path":"2019/01/12/表格固定表头和固定列/","link":"","permalink":"https://wangcherry.github.io/blog/2019/01/12/表格固定表头和固定列/","excerpt":"","text":"平时业务中经常会碰到固定表头或者固定列的需求，对于只固定表头或者固定列的情况可以使用两个表格，利用css实现。但是对于需要同时固定表头和列的情况，就需要四个表格完成样式，js监听滚动事件。如果表格数据比较多，样式复杂，性能就会受影响，效果不是很理想。那么，我们还有其他方式实现同时固定表头和列吗？ 答案是，yes 接下来给大家介绍下 position: sticky; 这个属性 position属性CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。position 常用值有： absolute（生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。） relative（生成相对定位的元素，相对于其正常位置进行定位。） fixed（生成固定定位的元素，相对于浏览器窗口进行定位。） sticky（生成粘性定位元素） 下面我们主要介绍的是粘性定位 粘性定位属性为 position: sticky 的元素是粘性定位元素。 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。举个栗子： git效果图： dt元素在到达顶部之前为相对定位，当元素的top为0之后，就固定在顶部。 查看源码 position: sticky; 实现表格固定表头和列一个表格轻松搞定表头和列固定 gif效果图： 查看源码 需要注意： 该粘性定位元素并不脱离文档流，仍然保留元素原本在文档流中的位置。 当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。 兼容性： 这个属性的兼容性还不是很好，目前仍是一个试验性的属性，并不是W3C推荐的标准。查看兼容性 js实现表格固定表头和列对兼容性要求高时可以考虑用js监听滚动实现固定 gif效果图： 查看源码","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wangcherry.github.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://wangcherry.github.io/blog/tags/css/"},{"name":"js","slug":"js","permalink":"https://wangcherry.github.io/blog/tags/js/"}]},{"title":"文件下载和页面打印","slug":"文件下载和页面打印","date":"2018-12-27T05:58:10.000Z","updated":"2019-03-04T07:04:30.190Z","comments":true,"path":"2018/12/27/文件下载和页面打印/","link":"","permalink":"https://wangcherry.github.io/blog/2018/12/27/文件下载和页面打印/","excerpt":"","text":"文件下载和页面打印在业务中有很多使用场景，它们的本质是一样的，都是向后端发一个请求，然后后端返回一个文件。浏览器将文件下载下来，（打印的情况，就是返回html文件，文件加载完之后调浏览器的打印）。 下面主要从文件下载讨论： 使用 a 标签最基础的用法，加 download 属性，浏览器下载该文件。缺点： 不能使用post方法 不能在启动下载时禁用按钮、下载完毕启用按钮1&lt;a href=\"/xhr/doc/ts实践总结&amp;ts解析.pptx\" download&gt;下载&lt;/a&gt; 关于 download 重命名 download 的值可作为文件的名称 后端如果对文件命名，那么会使用后端的命名 在后端没有命名时，以 download 的值为文件名称 都没命名时，或者 download 值设置为空时，下载的文件用文件本身的名称 window.open缺点： 异步回调函数里调 window.open 会被浏览器拦截12345678/** * 下载方法 * @param url * @param target */export const windowOpen = (url: string, target: string = '_blank') =&gt; &#123; window.open(url, target);&#125; 动态创建 a 标签如果在某些业务操作之后再下载的情况，就可以动态创建一个 a 标签。12345678910111213141516/** * 下载方法 * @param url * @param target */export const download = (url: string, target: string = '_blank', fileNmae: string = '') =&gt; &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target; a.download = fileNmae; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a);&#125;; iframe + form 不管是 a 标签还是 window.open ，在异步回调里都可能会被浏览器拦截（具体看浏览器，因为不是用户发起的页面跳转，有些浏览器会认为不安全） 或者是下载请求需要带复杂对象参数，需要用 post 方法，可以使用 iframe + form 利用表单的形式带参数。1234567891011121314151617181920212223242526272829303132333435363738/** * 下载方法 * @param url * @param target */export const download = (url: string, params: any) =&gt; &#123; const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125;&#125;; 使用 fetch 完成下载 对于 post 请求后端直接返回文件流的情况，可以使用 fetch 下载。 更多 Fetch 知识请查看MDN123456789101112/** * 下载方法 * @param url * @param target */ export const downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); ... // 动态创建 a 标签完成 &#125; DEMO源码html：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;p&gt;1：点击 下载 来下载文件：&lt;p&gt;&lt;p&gt;a 标签 &lt;a href=\"/xhr/doc/test.pptx\"&gt;下载&lt;/a&gt;&lt;/p&gt;&lt;p&gt;window.open 下载 &lt;button onclick=\"windowOpen('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;动态创建 a 标签 &lt;button onclick=\"createAEle('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;异步请求回调里下载 &lt;button onclick=\"downloadAfterAsync();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;ajax回调里下载 &lt;button onclick=\"downloadAfterAjax();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;form 表单提交 &lt;button onclick=\"formDownload('/xhr/doc/test.pptx',&#123;a:1,b:2&#125;);\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;使用fetch下载 &lt;button onclick=\"downloadByFetch();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function windowOpen(url) &#123; window.open(url,'_blank'); &#125; function createAEle(url, target, fileName) &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target || '_target'; a.download = fileName ? fileName : undefined; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a); &#125;; function downloadAfterAsync() &#123; const http = new XMLHttpRequest(); http.open('GET','/xhr/get/url.json'); http.send(); http.onreadystatechange = () =&gt; &#123; if(http.readyState === 4 &amp;&amp; http.status === 200) &#123; const url = http.responseText; // createAEle(url); // 有些浏览器，动态创建表单也会拦截 // windowOpen(url); // 异步回调里调用，浏览器会拦截 formDownload(url); // 不拦截 &#125; &#125; &#125; function downloadAfterAjax() &#123; $.ajax(&#123; method: 'GET', url: '/xhr/get/url.json', async: false // 将异步改为同步，浏览器不拦截 &#125;).done(url =&gt; &#123; windowOpen(url); &#125;); &#125; function formDownload(url, params) &#123;// 可以使用post方法，携带大对象参数 const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125; &#125; async function downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); createAEle(url, '_target', 'a.pptx'); &#125;&lt;/script&gt; server：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const Koa = require('koa');const path = require('path');const fse = require('fse');const static = require('koa-static');const opn = require('opn');const Router = require('koa-router')const bodyParser = require('koa-bodyparser');const app = new Koa();const router = new Router();const returnFile = async (ctx, next) =&gt; &#123; console.log(ctx.request.body);// post 方法提交的参数 let filePath = decodeURI(ctx.path.replace('/xhr/', '')); if (fse.existsSync(path.resolve(filePath))) &#123; ctx.set('Content-disposition', 'attachment; filename=a.pptx'); ctx.set('Content-Type', 'application/vnd.openxmlformats-officedocument.presentationml.presentation; charset=UTF-8'); console.log(path.resolve(filePath)) ctx.body = fse.readFileSync(path.resolve(filePath)); &#125; else &#123; console.log('error'); await next(); &#125;&#125;// 配置静态资源app.use(static( path.join(__dirname, './src')))// 使用ctx.body解析中间件app.use(bodyParser())// 请求router.get('/xhr/doc/:name', returnFile)router.post('/xhr/doc/:name', returnFile)// 请求router.get('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)router.post('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)app .use(router.routes()) .use(router.allowedMethods());opn('http://localhost:3001/');app.listen(3001);","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]}]}