{"meta":{"title":"小英英的博客","subtitle":null,"description":"越努力越幸运~","author":"小英英","url":"https://wangcherry.github.io/blog"},"pages":[],"posts":[{"title":"","slug":"严选工程化实践","date":"2019-12-24T09:30:50.556Z","updated":"2020-01-20T09:51:55.431Z","comments":true,"path":"2019/12/24/严选工程化实践/","link":"","permalink":"https://wangcherry.github.io/blog/2019/12/24/严选工程化实践/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"大量数据列表不卡顿的秘密","slug":"大量数据列表不卡顿的秘密","date":"2019-12-14T07:33:12.000Z","updated":"2019-12-14T07:34:35.935Z","comments":true,"path":"2019/12/14/大量数据列表不卡顿的秘密/","link":"","permalink":"https://wangcherry.github.io/blog/2019/12/14/大量数据列表不卡顿的秘密/","excerpt":"","text":"待写","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wangcherry.github.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://wangcherry.github.io/blog/tags/css/"},{"name":"js","slug":"js","permalink":"https://wangcherry.github.io/blog/tags/js/"}]},{"title":"nodejs开发CLI工具","slug":"nodejs开发CLI工具","date":"2019-09-25T01:34:34.000Z","updated":"2019-12-31T09:19:52.169Z","comments":true,"path":"2019/09/25/nodejs开发CLI工具/","link":"","permalink":"https://wangcherry.github.io/blog/2019/09/25/nodejs开发CLI工具/","excerpt":"","text":"在没有@vue/cli、create-react-app、@angular/cli这样子的脚手架时你是否遇到过一个文件一个文件的去拷贝老项目的配置文件？在开始使用脚手架后是否发现当前的脚手架不能完全贴合实际的业务场景？最近，我们组由angular框架转换成react框架，开发了一套完整的cli工具。写下这篇文章作为一个记录，希望大家看到后都能实现一个属于自己的脚手架工具。 CLI（command-line interface，命令行界面）是指可在用户提示符下键入可执行指令的界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。 准备工作主要分为以下几步： 新建一个项目并初始化package.json 开发前准备 获取参数 新建一个项目并初始化package.json12mkdir cli &amp; cd clinpm init 在package.json里配置命令，bin项用来指定各个内部命令对应的可执行文件的位置。这里 sr 就是我的命令了123\"bin\": &#123; \"sr\": \"./bin/index.js\"&#125; 开发前准备在bin文件夹下创建一个index.js ./bin/index.js123#!/usr/bin/env nodeconsole.log('my cli！'); 将命令链接到全局：1npm link 执行命令后，my-cli会根据package.json上的配置，sr 命令被链接到全局。更多npm link知识 这时在任何目录执行 sr 将会看到： 到这里就可以开始开发 cli 了，./bin/index.js 的更改会实时同步到全局命令的。 获取参数有了命令，那么具体子命令怎么执行呢？例如我输入 sr info 时希望能打印当前环境信息。效果如下： 首先，我们需要获取参数，因为知道是 info 命令，才能执行打印环境信息操作。那么怎么获取命令行参数呢？下面介绍用原始方法和使用模块获取命令行参数： 原始方法获取命令参数命令行参数可以用系统变量 process.argv 获取。（打印当前环境信息用 envinfo） ./bin/index.js123456789101112131415161718192021222324#!/usr/bin/env nodeconst envinfo = require('envinfo');if(process.argv[2] === 'info' ) &#123; envinfo .run( &#123; System: ['OS', 'CPU'], Binaries: ['Node', 'Yarn', 'npm'], Browsers: ['Chrome', 'Edge', 'Firefox', 'Safari'], npmPackages: ['envinfo'], npmGlobalPackages: ['@sharkr/cli'], &#125;, &#123; showNotFound: true, duplicates: true, fullTree: true, &#125; ) .then(console.log);&#125;else &#123; console.log('my cli！')&#125; 使用模块commander获取命令参数commander这个模块是node.js命令行界面的完整解决方案，不仅有着强大的参数解析功能，还提供了用户命令行输入，是cli开发的一个很好选择。 ./bin/index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env nodeconst envinfo = require('envinfo');const program = require('commander');program .version(require('../package').version) .usage('&lt;command&gt; [options]');program .command('info') .description('Print debugging information about your environment') .option('-s, --show-not-found', 'show not found package') .action((cmd) =&gt; &#123; const options = cleanArgs(cmd); console.log(options) envinfo .run( &#123; System: ['OS', 'CPU'], Binaries: ['Node', 'Yarn', 'npm'], Browsers: ['Chrome', 'Edge', 'Firefox', 'Safari'], npmPackages: ['envinfo'], npmGlobalPackages: ['@sharkr/cli', 'xxx'], &#125;, &#123; showNotFound: options.showNotFound, duplicates: true, fullTree: true, &#125; ) .then(console.log); &#125;);program.parse(process.argv);function camelize(str) &#123; return str.replace(/-(\\w)/g, (_, c) =&gt; (c ? c.toUpperCase() : ''));&#125;function cleanArgs(cmd) &#123; const args = &#123;&#125;; cmd.options.forEach(o =&gt; &#123; const key = camelize(o.long.replace(/^--/, '')); if (typeof cmd[key] !== 'function' &amp;&amp; typeof cmd[key] !== 'undefined') &#123; args[key] = cmd[key]; &#125; &#125;); return args;&#125; command：子命令 description：命令描述 option：配置项 action：命令对应要执行的方法 cleanArgs 函数将 option 处理成键值对，方便使用 program.parse(process.argv) 解析命令参数 init命令经过上面的准备工作，cli 已经可以获取命令和参数了，那么接下来就可以开始写命令对应的操作了。作为项目的脚手架，第一步当然是初始化一个项目。分为以下两步完成： 准备模板 编写init命令 准备模板我们的模板都放在 gitlab 维护，init 时从 gitlab clone，这么做主要是考虑到我们模板比较多，且前期模板不稳定，避免模板更新时需要频繁更新 cli。多个模板可以通过配置项来选择。 编写init命令以下是省去很多校验和兼容处理的一个init命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546program .command('init &lt;app-name&gt;') .description('Init a new react project') .option('-t, --type &lt;type&gt;', 'Set template type') .option('-y, --useYarn', 'Use yarn install (default use npm)') .action(async (appName, cmd) =&gt; &#123; const options = cleanArgs(cmd); // 获取代码前可以进行一些特性对话 let templateGit; if (options.type) &#123; // 虚构的git模板地址 templateGit = `git@github.com:sharkr/react-template/$&#123; options.type &#125;.git`; &#125; else &#123; const &#123; type &#125; = await inquirer.prompt([ &#123; name: 'type', type: 'list', message: `Select template type:`, choices: [ &#123; name: 'full, include server &amp; web', value: 'full' &#125;, &#123; name: 'web, only web template', value: 'web' &#125;, &#123; name: 'npm, include server &amp; web for package', value: 'npm' &#125; ], default: 'full', &#125;, ]); // 虚构的git模板地址 templateGit = `git@github.com:sharkr/react-template/$&#123;type&#125;.git`; &#125; // clone代码 execSync(`git clone $&#123;templateGit&#125; $&#123;appName&#125;`, &#123; stdio: 'ignore' &#125;); const appPath = path.resolve(appName); process.chdir(appPath); fse.removeSync(path.join(appPath, '.git')); // 这里可以对模板做一下处理 // 根据配置项install if(options.useYarn) &#123; spawn('yarn', ['install'], &#123; stdio: 'inherit' &#125;); &#125;else &#123; spawn('npm', ['install'], &#123; stdio: 'inherit' &#125;); &#125; &#125;); 执行 sr init my-app init 命令提供一个配置项 type 设置需要拉取的模板类型，我们可以执行 sr init my-app 初始化项目，没设置 type 时需要选择模板类型。执行 sr init my-app -t full 时直接拉取full模板。在实际开发中，可以根据模板的用途做更多的特性选择和处理。 小结：在命令行工具的开发过程中，使用commander、inquirer和chalk等一些npm插件，可以很好的完成命令行工具的开发，并且可以达到很棒的效果，感兴趣的话，赶快试试吧，做一款自己的命令行工具。","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"},{"name":"cli","slug":"cli","permalink":"https://wangcherry.github.io/blog/tags/cli/"}]},{"title":"nodejs实现http和https代理服务","slug":"nodejs实现http和https代理服务","date":"2019-04-30T02:22:55.000Z","updated":"2019-12-31T09:26:54.495Z","comments":true,"path":"2019/04/30/nodejs实现http和https代理服务/","link":"","permalink":"https://wangcherry.github.io/blog/2019/04/30/nodejs实现http和https代理服务/","excerpt":"","text":"http/https协议作为一个程序员，我们经常会使用到代理，例如将本地请求转到测试环境以完成联调；或将某些请求转发到指定服务器等。那么代理转发的实现原理是什么呢？下面将介绍nodejs如何实现http和https代理服务。 关于HTTP和HTTPS协议： HTTP(Hypertext Transfer Protocol，超文本传输协议) 在OSI七层模型属于应用层协议，在网络与传输层使用可靠的数据传输协议TCP/IP，HTTP协议采用明文传输信息的方式。 HTTPS (Secure Hypertext Transfer Protocol，安全超文本传输协议）是一个安全通信通道，基于HTTP开发，用于在客户端和服务器之间交换信息时采用安全套接字层(SSL)进行信息交换。通俗地讲，HTTPS是HTTP的安全版，即使用了TLS/SSL加密的HTTP协议。 http/https代理原理下面主要介绍两种代理实现，一种是“中间人”代理（《http权威指南》第六章），还有一种是隧道代理（《http权威指南》第八章） “中间人”代理MITM（中间人）代理在实际开发和测试中经常会使用。调试接口、查看HTTP请求与响应时使用的http抓包调试工具如：Fiddler、 Charles，就是基于该原理实现的。用户通过设置代理，网络请求就会通过中间人代理，再发往正式服务器。 所以我们的实现原理就是建立一个可以同时与客户端和服务端进行通信的网络服务。 中间人代理示意图（来源于《HTTP权威指南》）： HTTP客户端会向代理发送请求报文，代理服务器必须像Web服务器一样，正确的处理请求和连接，然后返回响应。同时，代理自身要向服务器发送请求，这样，其行为就必须像正确的HTTP客户端一样，要发送请求并接受响应。 那么http代理的实现方案就是： 此时的代理就是“中间人”，代理拦截到请求之后可以修改请求数据，再向服务器发起请求，获取到数据后也可以修改数据，再返回给客户端。当然，代理也可以不向服务器发起请求，而是直接返回本地的数据，那就是数据mock。 用node运行下面代码（注意需要设置开启代理）12345678910111213141516171819202122232425262728const http = require('http');const url = require('url');function request(req, res) &#123; const u = url.parse(req.url); const options = &#123; hostname : u.hostname, port : u.port || 80, path : u.path, method : req.method, headers : req.headers &#125;; const proxyReq = http.request(options, function(proxyRes) &#123; console.log('http proxy：' + options.hostname); res.writeHead(proxyRes.statusCode, proxyRes.headers); proxyRes.pipe(res); &#125;).on('error', function(e) &#123; res.end(); &#125;); req.pipe(proxyReq);&#125;const proxy = http.createServer(request);proxy.listen(8888); 隧道代理上面已经完成了HTTP代理，那么是不是将HTTP换成HTTPS就能实现HTTPS代理呢？答案是不能，首先我们来看下HTTP和HTTPS去区别： 从上图可以知道HTTPS的分层是在传输层之上建立了安全层，所有的HTTP请求都在安全层上传输。所以对于http代理，我们只需要拦截请求，就可获取到报文信息从而完成转发。但是对于https请求，我们无法获取安全层数据。更多SSL/TLS协议知识可以参考SSL/TLS协议运行机制的概述 那么我们如何转发HTTPS流量呢。方法就是在客户端和服务器之间建立一条Web隧道。Web隧道用HTTP的CONNECT方法建立起来的。 CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。这种方法不仅能代理HTTPS请求，理论上可以代理所有基于TCP协议的请求。不过HTTP流量代理会耗费一次TCP连接，所以默认HTTP流量不走隧道代理。 下图显示了CONNECT方法如何建立一条到达网关的隧道（来源于《HTTP权威指南》）： 那么隧道代理的实现方案就是： 第一步：客户端像http代理发起CONNECT请求。第二步：http代理接收到CONNECT请求后与abc.com的433端口建立tcp连接。第三步：与abc.com的433端口建立tcp连接成功，通知客户端。 隧道连接示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const http = require('http');const net = require('net');const url = require('url');function request(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end('响应内容');&#125;function connect(req, cltSocket, head) &#123; console.log('TCP连接已完成'); // 连接到原始服务器。 const srvUrl = url.parse(`http://$&#123;req.url&#125;`); const srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () =&gt; &#123; cltSocket.write('HTTP/1.1 200 Connection Established\\r\\n' + 'Proxy-agent: Node.js-Proxy\\r\\n' + '\\r\\n'); srvSocket.write(head); srvSocket.pipe(cltSocket); cltSocket.pipe(srvSocket); &#125;);&#125;// 创建 HTTP 隧道代理。const proxy = http.createServer(request);proxy.on('connect', connect);// 代理正在运行。proxy.listen(8888, '127.0.0.1', () =&gt; &#123; // 向隧道代理发出请求。 const options = &#123; port: 8888, host: '127.0.0.1', method: 'CONNECT', path: 'nodejs.cn:80' &#125;; const req = http.request(options); req.end(); req.on('connect', (res, socket, head) =&gt; &#123; console.log('已连接'); // 通过 HTTP 隧道发出请求。 socket.write('GET / HTTP/1.1\\r\\n' + 'Host: nodejs.cn:80\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n'); socket.on('data', (chunk) =&gt; &#123; console.log(chunk.toString()); &#125;); socket.on('end', () =&gt; &#123; proxy.close(); &#125;); &#125;);&#125;); 解析HTTPS请求明文信息如果我们需要将请求转发到指定目标服务器，那么就需要解析HTTPS的请求报文了。我们都知道SSL的三大功能：内容加密、身份验证和校验机制，校验机制依赖于 MAC（Message authentication code）校验机制，下面主要谈一下身份验证和内容加密。 首先，我们需要支持身份认证，才能建立安全连接，身份认证依赖于证书认证机制。域名证书 是每个支持HTTPS网站都需要有的一份证书，用于客户端验证该网站的安全性，而该证书通常是通过安全机构申请的，这个机构就是 CA（Certificate Authority，证书颁发机构）。在每台用户计算机的操作系统或浏览器中，都会维护一份受信任的CA列表，浏览器在获取到域名证书之后，会向CA根证书进行验证，包含在列表之中的证书，或者由列表中的证书签发的证书都会被客户端信任，如果验证通过则能正常收发请求。 客户端验证服务器证书示意图： 由于代理服务器并没有合法的域名证书（证书只存在真实目标服务器，无法获取到），所以我们需要在代理服务器上伪造证书，实现方案是，node生成根证书，安装并信任，在拦截到https请求时，我们利用根证书动态签发域名证书，并将证书返回给浏览器，浏览器验证证书，由于域名证书是我们信任的根证书签发的，所以会验证通过。 生成根证书：12openssl genrsa -out private.pem 2048openssl req -new -x509 -key private.pem -out public.crt -days 99999 注意运行第二条信息时，需要填写一些证书信息，我们是本地测试，Common Name 可以填写127.0.0.1。然后安装并信任即可（安装信任证书请自行百度） 最后，我们来看下代理服务器如何解析HTTPS请求报文。我们知道，SSL的内容加密功能依赖于密钥协商机制， 报文信息加密解密示意图（简化版）： 1，建立连接时，客户端发起请求；代理拦截后生成域名证书B和私钥b，并用私钥b给证书B签名；同时，代理跟服务器建立连接；服务器用私钥a给证书A签名，并返回给代理；代理将证书B返回给客户端。随后客户端随机生成主密钥M，并用证书B加密，由主密钥生成会话密钥Q；代理拦截后用私钥b解密获得主密钥M，并随机生成主密钥N，用证书A加密发往服务器，并由主密钥生成会话密钥P；服务器解密获得主密钥N。2，完成连接后，客户端用会话密钥Q加密请求；代理拦截后解密获得明文信息，再用会话密钥P加密发往服务器；服务器解密获得明文信息，返回数据； 到此，我们的代理就能解析HTTPS请求的明文信息了，也可以修改信息后发往目标服务器，从而实现HTTPS代理。 最后代理服务器可以实现各种时髦且有用的功能。它们可以改善安全性，提高性能，节省费用。代理服务器可以看到并接触到所有流过的HTTP流量，所以代理服务器可以监视流量并对其进行修改，以实现很多有用的增值Web服务。希望以上的原理介绍可以帮助到大家更好的理解代理服务。","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"},{"name":"http","slug":"http","permalink":"https://wangcherry.github.io/blog/tags/http/"}]},{"title":"barrel文件引起循环依赖","slug":"barrel文件引起循环依赖","date":"2019-04-08T06:07:48.000Z","updated":"2019-12-31T09:21:32.024Z","comments":true,"path":"2019/04/08/barrel文件引起循环依赖/","link":"","permalink":"https://wangcherry.github.io/blog/2019/04/08/barrel文件引起循环依赖/","excerpt":"","text":"在给QDC项目升级时，碰到这样一个报错。server没问题，build时报错 没有报具体错误，按照报错翻译应该是“遇到未定义的provider，通常意味着有一个循环依赖，可能是由于使用“barrel” index.ts 文件引起的”。于是我检查项目中的 provider 使用没有问题，检查了各个模块之间的依赖也没有问题，注意到项目中写了很多index.ts文件，咋一看没有什么问题，比较难发现，但是仔细看index的引用发现barrel使用时有些坑需要注意。 Barrel先介绍一下Barrel，barrel是将多个模块的导出汇总到一个模块的一种方法。barrel本身是一个模块文件，可以重新导出其他模块的选定导出。 例如有三个模块123456789101112131415161718// heroes/hero.component.tsexport class HeroComponent &#123;&#125;// heroes/hero.model.tsexport class Hero &#123;&#125;// heroes/hero.service.tsexport class HeroService &#123;&#125;// index.tsexport * from './hero.model.ts'; // re-export all of its exportsexport * from './hero.service.ts'; // re-export all of its exportsexport &#123; HeroComponent &#125; from './hero.component.ts'; // re-export the named thing// used barrelimport &#123; Hero, HeroService &#125; from '../heroes'; // index is implied// without barrelexport &#123; Hero &#125; from '../heroes/hero.model.ts';export &#123; HeroService &#125; from '../heroes/hero.service.ts'; Barrel的坑在导入同一个模块中的文件时使用barrel可以让文件看起来更清爽，但是在使用时需要注意，因为使用不当可能会引起循环依赖。在这个DQC这个项目中，依赖了@datapi/dscomponent这个包，包在本地打包没问题，但是发成npm包被项目引用后，项目打包就报上面的错误。我简化下，还原报错原因。 目录结构：|—service|—|—a.service.ts|—|—b.service.ts|—|—index.ts|—table|—|—…|—|—table.module.ts 例如如下使用1234567891011121314// a.service.tsexport class AService &#123; &#125;// index.tsexport * from './a.service.ts';export * from './b.service.ts';// table.module.tsimport &#123; AService &#125; from '../service';@NgModule(&#123; ... providers: [AService]&#125;)export class TableModule &#123; &#125; import { AService } from &#39;../service&#39;; 改为 import { AService } from &#39;../service/a.service.ts&#39;; 后问题得到解决 angular风格指南angular团队已经不推荐barrel这种写法，在风格指南已经删除相关写法。 所以删除项目中的barrel，改为具体文件导入。 参考文章Angular DI Error - EXCEPTION: Can’t resolve all parametersBarrel and Circular dependency","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]},{"title":"表格固定表头和固定列","slug":"表格固定表头和固定列","date":"2019-01-12T08:26:52.000Z","updated":"2019-12-31T09:30:30.036Z","comments":true,"path":"2019/01/12/表格固定表头和固定列/","link":"","permalink":"https://wangcherry.github.io/blog/2019/01/12/表格固定表头和固定列/","excerpt":"","text":"平时业务中经常会碰到固定表头或者固定列的需求，对于只固定表头或者固定列的情况可以使用两个表格，利用css实现。但是对于需要同时固定表头和列的情况，就需要四个表格完成样式，js监听滚动事件。如果表格数据比较多，样式复杂，性能就会受影响，效果不是很理想。那么，我们还有其他方式实现同时固定表头和列吗？ 答案是，yes 接下来给大家介绍下 position: sticky; 这个属性 position属性CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。position 常用值有： absolute（生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。） relative（生成相对定位的元素，相对于其正常位置进行定位。） fixed（生成固定定位的元素，相对于浏览器窗口进行定位。） sticky（生成粘性定位元素） 下面我们主要介绍的是粘性定位 粘性定位属性为 position: sticky 的元素是粘性定位元素。 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。举个栗子： git效果图： dt元素在到达顶部之前为相对定位，当元素的top为0之后，就固定在顶部。 查看源码 position: sticky; 实现表格固定表头和列一个表格轻松搞定表头和列固定 gif效果图： 查看源码 需要注意： 该粘性定位元素并不脱离文档流，仍然保留元素原本在文档流中的位置。 当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。 兼容性： 这个属性的兼容性还不是很好，目前仍是一个试验性的属性，并不是W3C推荐的标准。查看兼容性! js实现表格固定表头和列对兼容性要求高时可以考虑用js监听滚动实现固定 gif效果图： ! 查看源码","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wangcherry.github.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://wangcherry.github.io/blog/tags/css/"},{"name":"js","slug":"js","permalink":"https://wangcherry.github.io/blog/tags/js/"}]},{"title":"文件下载和页面打印","slug":"文件下载和页面打印","date":"2018-12-27T05:58:10.000Z","updated":"2019-03-04T07:04:30.190Z","comments":true,"path":"2018/12/27/文件下载和页面打印/","link":"","permalink":"https://wangcherry.github.io/blog/2018/12/27/文件下载和页面打印/","excerpt":"","text":"文件下载和页面打印在业务中有很多使用场景，它们的本质是一样的，都是向后端发一个请求，然后后端返回一个文件。浏览器将文件下载下来，（打印的情况，就是返回html文件，文件加载完之后调浏览器的打印）。 下面主要从文件下载讨论： 使用 a 标签最基础的用法，加 download 属性，浏览器下载该文件。缺点： 不能使用post方法 不能在启动下载时禁用按钮、下载完毕启用按钮1&lt;a href=\"/xhr/doc/ts实践总结&amp;ts解析.pptx\" download&gt;下载&lt;/a&gt; 关于 download 重命名 download 的值可作为文件的名称 后端如果对文件命名，那么会使用后端的命名 在后端没有命名时，以 download 的值为文件名称 都没命名时，或者 download 值设置为空时，下载的文件用文件本身的名称 window.open缺点： 异步回调函数里调 window.open 会被浏览器拦截12345678/** * 下载方法 * @param url * @param target */export const windowOpen = (url: string, target: string = '_blank') =&gt; &#123; window.open(url, target);&#125; 动态创建 a 标签如果在某些业务操作之后再下载的情况，就可以动态创建一个 a 标签。12345678910111213141516/** * 下载方法 * @param url * @param target */export const download = (url: string, target: string = '_blank', fileNmae: string = '') =&gt; &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target; a.download = fileNmae; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a);&#125;; iframe + form 不管是 a 标签还是 window.open ，在异步回调里都可能会被浏览器拦截（具体看浏览器，因为不是用户发起的页面跳转，有些浏览器会认为不安全） 或者是下载请求需要带复杂对象参数，需要用 post 方法，可以使用 iframe + form 利用表单的形式带参数。1234567891011121314151617181920212223242526272829303132333435363738/** * 下载方法 * @param url * @param target */export const download = (url: string, params: any) =&gt; &#123; const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125;&#125;; 使用 fetch 完成下载 对于 post 请求后端直接返回文件流的情况，可以使用 fetch 下载。 更多 Fetch 知识请查看MDN123456789101112/** * 下载方法 * @param url * @param target */ export const downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); ... // 动态创建 a 标签完成 &#125; DEMO源码html：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;p&gt;1：点击 下载 来下载文件：&lt;p&gt;&lt;p&gt;a 标签 &lt;a href=\"/xhr/doc/test.pptx\"&gt;下载&lt;/a&gt;&lt;/p&gt;&lt;p&gt;window.open 下载 &lt;button onclick=\"windowOpen('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;动态创建 a 标签 &lt;button onclick=\"createAEle('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;异步请求回调里下载 &lt;button onclick=\"downloadAfterAsync();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;ajax回调里下载 &lt;button onclick=\"downloadAfterAjax();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;form 表单提交 &lt;button onclick=\"formDownload('/xhr/doc/test.pptx',&#123;a:1,b:2&#125;);\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;使用fetch下载 &lt;button onclick=\"downloadByFetch();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function windowOpen(url) &#123; window.open(url,'_blank'); &#125; function createAEle(url, target, fileName) &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target || '_target'; a.download = fileName ? fileName : undefined; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a); &#125;; function downloadAfterAsync() &#123; const http = new XMLHttpRequest(); http.open('GET','/xhr/get/url.json'); http.send(); http.onreadystatechange = () =&gt; &#123; if(http.readyState === 4 &amp;&amp; http.status === 200) &#123; const url = http.responseText; // createAEle(url); // 有些浏览器，动态创建表单也会拦截 // windowOpen(url); // 异步回调里调用，浏览器会拦截 formDownload(url); // 不拦截 &#125; &#125; &#125; function downloadAfterAjax() &#123; $.ajax(&#123; method: 'GET', url: '/xhr/get/url.json', async: false // 将异步改为同步，浏览器不拦截 &#125;).done(url =&gt; &#123; windowOpen(url); &#125;); &#125; function formDownload(url, params) &#123;// 可以使用post方法，携带大对象参数 const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125; &#125; async function downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); createAEle(url, '_target', 'a.pptx'); &#125;&lt;/script&gt; server：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const Koa = require('koa');const path = require('path');const fse = require('fse');const static = require('koa-static');const opn = require('opn');const Router = require('koa-router')const bodyParser = require('koa-bodyparser');const app = new Koa();const router = new Router();const returnFile = async (ctx, next) =&gt; &#123; console.log(ctx.request.body);// post 方法提交的参数 let filePath = decodeURI(ctx.path.replace('/xhr/', '')); if (fse.existsSync(path.resolve(filePath))) &#123; ctx.set('Content-disposition', 'attachment; filename=a.pptx'); ctx.set('Content-Type', 'application/vnd.openxmlformats-officedocument.presentationml.presentation; charset=UTF-8'); console.log(path.resolve(filePath)) ctx.body = fse.readFileSync(path.resolve(filePath)); &#125; else &#123; console.log('error'); await next(); &#125;&#125;// 配置静态资源app.use(static( path.join(__dirname, './src')))// 使用ctx.body解析中间件app.use(bodyParser())// 请求router.get('/xhr/doc/:name', returnFile)router.post('/xhr/doc/:name', returnFile)// 请求router.get('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)router.post('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)app .use(router.routes()) .use(router.allowedMethods());opn('http://localhost:3001/');app.listen(3001);","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]}]}