{"meta":{"title":"小英英的博客","subtitle":null,"description":"越努力越幸运~","author":"小英英","url":"https://wangcherry.github.io/blog"},"pages":[],"posts":[{"title":"表格固定表头和固定列","slug":"表格固定表头和固定列","date":"2019-01-12T08:26:52.000Z","updated":"2019-01-15T01:47:31.611Z","comments":true,"path":"2019/01/12/表格固定表头和固定列/","link":"","permalink":"https://wangcherry.github.io/blog/2019/01/12/表格固定表头和固定列/","excerpt":"","text":"平时业务中经常会碰到固定表头或者固定列的需求，对于只固定表头或者固定列的情况可以使用两个表格，利用css实现。但是对于需要同时固定表头和列的情况，就需要四个表格完成样式，js监听滚动事件。如果表格数据比较多，样式复杂，性能就会受影响，效果不是很理想。那么，我们还有其他方式实现同时固定表头和列吗？ 答案是，yes 接下来给大家介绍下 position: sticky; 这个属性 position属性CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。position 常用值有： absolute（生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。） relative（生成相对定位的元素，相对于其正常位置进行定位。） fixed（生成固定定位的元素，相对于浏览器窗口进行定位。） sticky（生成粘性定位元素） 下面我们主要介绍的是粘性定位 粘性定位属性为 position: sticky 的元素是粘性定位元素。 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。举个栗子： git效果图： dt元素在到达顶部之前为相对定位，当元素的top为0之后，就固定在顶部。 查看源码 position: sticky; 实现表格固定表头和列一个表格轻松搞定表头和列固定 gif效果图： 查看源码 需要注意： 该粘性定位元素并不脱离文档流，仍然保留元素原本在文档流中的位置。 当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。 兼容性： 这个属性的兼容性还不是很好，目前仍是一个试验性的属性，并不是W3C推荐的标准。查看兼容性 js实现表格固定表头和列对兼容性要求高时可以考虑用js监听滚动实现固定 gif效果图： 查看源码","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wangcherry.github.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://wangcherry.github.io/blog/tags/css/"},{"name":"js","slug":"js","permalink":"https://wangcherry.github.io/blog/tags/js/"}]},{"title":"文件下载和页面打印","slug":"文件下载和页面打印","date":"2018-12-27T05:58:10.000Z","updated":"2019-03-04T07:04:30.190Z","comments":true,"path":"2018/12/27/文件下载和页面打印/","link":"","permalink":"https://wangcherry.github.io/blog/2018/12/27/文件下载和页面打印/","excerpt":"","text":"文件下载和页面打印在业务中有很多使用场景，它们的本质是一样的，都是向后端发一个请求，然后后端返回一个文件。浏览器将文件下载下来，（打印的情况，就是返回html文件，文件加载完之后调浏览器的打印）。 下面主要从文件下载讨论： 使用 a 标签最基础的用法，加 download 属性，浏览器下载该文件。缺点： 不能使用post方法 不能在启动下载时禁用按钮、下载完毕启用按钮1&lt;a href=\"/xhr/doc/ts实践总结&amp;ts解析.pptx\" download&gt;下载&lt;/a&gt; 关于 download 重命名 download 的值可作为文件的名称 后端如果对文件命名，那么会使用后端的命名 在后端没有命名时，以 download 的值为文件名称 都没命名时，或者 download 值设置为空时，下载的文件用文件本身的名称 window.open缺点： 异步回调函数里调 window.open 会被浏览器拦截12345678/** * 下载方法 * @param url * @param target */export const windowOpen = (url: string, target: string = '_blank') =&gt; &#123; window.open(url, target);&#125; 动态创建 a 标签如果在某些业务操作之后再下载的情况，就可以动态创建一个 a 标签。12345678910111213141516/** * 下载方法 * @param url * @param target */export const download = (url: string, target: string = '_blank', fileNmae: string = '') =&gt; &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target; a.download = fileNmae; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a);&#125;; iframe + form 不管是 a 标签还是 window.open ，在异步回调里都可能会被浏览器拦截（具体看浏览器，因为不是用户发起的页面跳转，有些浏览器会认为不安全） 或者是下载请求需要带复杂对象参数，需要用 post 方法，可以使用 iframe + form 利用表单的形式带参数。1234567891011121314151617181920212223242526272829303132333435363738/** * 下载方法 * @param url * @param target */export const download = (url: string, params: any) =&gt; &#123; const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125;&#125;; 使用 fetch 完成下载 对于 post 请求后端直接返回文件流的情况，可以使用 fetch 下载。 更多 Fetch 知识请查看MDN123456789101112/** * 下载方法 * @param url * @param target */ export const downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); ... // 动态创建 a 标签完成 &#125; DEMO源码html：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;p&gt;1：点击 下载 来下载文件：&lt;p&gt;&lt;p&gt;a 标签 &lt;a href=\"/xhr/doc/test.pptx\"&gt;下载&lt;/a&gt;&lt;/p&gt;&lt;p&gt;window.open 下载 &lt;button onclick=\"windowOpen('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;动态创建 a 标签 &lt;button onclick=\"createAEle('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;异步请求回调里下载 &lt;button onclick=\"downloadAfterAsync();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;ajax回调里下载 &lt;button onclick=\"downloadAfterAjax();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;form 表单提交 &lt;button onclick=\"formDownload('/xhr/doc/test.pptx',&#123;a:1,b:2&#125;);\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;使用fetch下载 &lt;button onclick=\"downloadByFetch();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function windowOpen(url) &#123; window.open(url,'_blank'); &#125; function createAEle(url, target, fileName) &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target || '_target'; a.download = fileName ? fileName : undefined; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a); &#125;; function downloadAfterAsync() &#123; const http = new XMLHttpRequest(); http.open('GET','/xhr/get/url.json'); http.send(); http.onreadystatechange = () =&gt; &#123; if(http.readyState === 4 &amp;&amp; http.status === 200) &#123; const url = http.responseText; // createAEle(url); // 有些浏览器，动态创建表单也会拦截 // windowOpen(url); // 异步回调里调用，浏览器会拦截 formDownload(url); // 不拦截 &#125; &#125; &#125; function downloadAfterAjax() &#123; $.ajax(&#123; method: 'GET', url: '/xhr/get/url.json', async: false // 将异步改为同步，浏览器不拦截 &#125;).done(url =&gt; &#123; windowOpen(url); &#125;); &#125; function formDownload(url, params) &#123;// 可以使用post方法，携带大对象参数 const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125; &#125; async function downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); createAEle(url, '_target', 'a.pptx'); &#125;&lt;/script&gt; server：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const Koa = require('koa');const path = require('path');const fse = require('fse');const static = require('koa-static');const opn = require('opn');const Router = require('koa-router')const bodyParser = require('koa-bodyparser');const app = new Koa();const router = new Router();const returnFile = async (ctx, next) =&gt; &#123; console.log(ctx.request.body);// post 方法提交的参数 let filePath = decodeURI(ctx.path.replace('/xhr/', '')); if (fse.existsSync(path.resolve(filePath))) &#123; ctx.set('Content-disposition', 'attachment; filename=a.pptx'); ctx.set('Content-Type', 'application/vnd.openxmlformats-officedocument.presentationml.presentation; charset=UTF-8'); console.log(path.resolve(filePath)) ctx.body = fse.readFileSync(path.resolve(filePath)); &#125; else &#123; console.log('error'); await next(); &#125;&#125;// 配置静态资源app.use(static( path.join(__dirname, './src')))// 使用ctx.body解析中间件app.use(bodyParser())// 请求router.get('/xhr/doc/:name', returnFile)router.post('/xhr/doc/:name', returnFile)// 请求router.get('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)router.post('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)app .use(router.routes()) .use(router.allowedMethods());opn('http://localhost:3001/');app.listen(3001);","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]}]}