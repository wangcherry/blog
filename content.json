{"meta":{"title":"小英英的博客","subtitle":null,"description":"越努力越幸运~","author":"小英英","url":"https://wangcherry.github.io/blog"},"pages":[],"posts":[{"title":"nodejs实现http和https代理服务","slug":"nodejs实现http和https代理服务","date":"2019-04-30T02:22:55.000Z","updated":"2019-05-07T07:30:45.011Z","comments":true,"path":"2019/04/30/nodejs实现http和https代理服务/","link":"","permalink":"https://wangcherry.github.io/blog/2019/04/30/nodejs实现http和https代理服务/","excerpt":"","text":"http/https协议HTTP(Hypertext Transfer Protocol，超文本传输协议) 在OSI七层模型属于应用层协议，在网络与传输层使用可靠的数据传输协议TCP/IP，HTTP协议采用明文传输信息的方式。 HTTPS (Secure Hypertext Transfer Protocol，安全超文本传输协议）是一个安全通信通道，基于HTTP开发，用于在客户端和服务器之间交换信息时采用安全套接字层(SSL)进行信息交换。通俗地讲，HTTPS是HTTP的安全版，即使用了TLS/SSL加密的HTTP协议。 从上图可以知道HTTPS的分层是在传输层之上建立了安全层，所有的HTTP请求都在安全层上传输。所以对于http代理，我们只需要拦截请求，就可获取到信息，但是对于https代理，我还需要做一些处理才能拿到请求明文信息。更多SSL/TLS协议知识可以参考SSL/TLS协议运行机制的概述 http/https代理原理“中间人”代理MITM（中间人）代理的技术在实际开发和测试中经常会使用。调试接口、查看HTTP请求与响应时使用的http抓包调试工具如：Fiddler、 Charles，就是基于该原理实现的。用户通过设置代理，网络请求就会通过中间人代理，再发往正式服务器。 所以我们的实现原理就是建立一个可以同时与客户端和服务端进行通信的网络服务。 中间人代理有两种实现方式，一种如下示意图： 那么http代理的实现方案就是： 此时的代理就是“中间人”，代理拦截到请求之后可以修改请求数据，再向服务器发起请求，获取到数据后也可以修改数据，再返回给客户端。 12345678910111213141516171819202122232425262728const http = require('http');const url = require('url');function request(cReq, cRes) &#123; const u = url.parse(cReq.url); const options = &#123; hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers &#125;; const pReq = http.request(options, function(pRes) &#123; // console.log(options); cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); &#125;).on('error', function(e) &#123; cRes.end(); &#125;); cReq.pipe(pReq);&#125;const server = http.createServer(request);server.listen(8888); 另外一种实现方式是TCP隧道： 由于https请求数据在安全层上传输，我们不能像http请求那样直接解析请求报文，但是，我们可以开启一个TCP服务，监听CONNECT请求，因为应用层也是基于传输层的，所以数据在到达应用层之前会首先经过传输层，从而实现传输层数据监听。这种方式就像为客户端和服务器之间打通了一条TCP连接的隧道，作为HTTP代理对隧道里传输的内容一概不予理会，只负责传输。所以隧道代理可以代理所有基于TCP的流量，http数据也是可以监听到，不过会浪费一次TCP连接往返。 TCP隧道连接如下示意图： 那么隧道连接代码实现方案： 1234567891011121314151617181920212223const net = require('net');const http = require('http');const url = require('url');function connect(cReq, cSock) &#123; const u = url.parse('http://' + cReq.url); const pSock = net.connect(u.port, u.hostname, function() &#123; // console.log(u); cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); &#125;).on('error', function(e) &#123; cSock.end(); &#125;); cSock.pipe(pSock);&#125;const server = http.createServer();server.on('connect', connect);server.listen(8888); 最后，我们还需要支持域名证书验证，才能拿到https的请求明文信息。域名证书 是每个支持HTTPS网站都需要有的一份证书，用于客户端验证该网站的安全性，而该证书通常是通过安全机构申请的，这个机构就是 CA（Certificate Authority，证书颁发机构）。在每台用户计算机的操作系统或浏览器中，都会保存一份CA列表，也就是有多个根证书，不同CA分别包含了不同的域名证书，浏览器在获取到域名证书之后，会向CA根证书进行验证，如果验证通过则能正常收发请求。所以我们需要在代理服务器上伪造证书，实现方案是，node生成根证书，安装并信任，在拦截到https请求时，我们利用根证书动态签发域名证书，并将证书返回给浏览器，浏览器验证证书，由于域名证书是我们信任的根证书签发的，所以会验证通过。于是我们也能解析请求报文了。 生成根证书：12openssl genrsa -out private.pem 2048openssl req -new -x509 -key private.pem -out public.crt -days 99999 安装并信任即可 伪造证书示意图： 那么https代理的实现方案就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const http = require('http');const https = require('https');const fs = require('fs');const net = require('net');const url = require('url');function request(cReq, cRes) &#123; const u = url.parse(cReq.url); const options = &#123; hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers &#125;; const pReq = http.request(options, function(pRes) &#123; cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); &#125;).on('error', function(e) &#123; cRes.end(); &#125;); cReq.pipe(pReq);&#125;function connect(cReq, cSock) &#123; const u = url.parse('http://' + cReq.url); const pSock = net.connect(u.port, u.hostname, function() &#123; cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); &#125;).on('error', function(e) &#123; cSock.end(); &#125;); cSock.pipe(pSock);&#125;const options = &#123; key : fs.readFileSync('./private.pem'), cert : fs.readFileSync('./public.crt')&#125;;const server = https.createServer(options)server.on('request', request)server.on('connect', connect)server.listen(8888);","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"}]},{"title":"barrel文件引起循环依赖","slug":"barrel文件引起循环依赖","date":"2019-04-08T06:07:48.000Z","updated":"2019-04-09T02:31:26.871Z","comments":true,"path":"2019/04/08/barrel文件引起循环依赖/","link":"","permalink":"https://wangcherry.github.io/blog/2019/04/08/barrel文件引起循环依赖/","excerpt":"","text":"在给QDC项目升级时，碰到这样一个报错。server没问题，build时报错 没有报具体错误，按照报错翻译应该是“遇到未定义的provider，通常意味着有一个循环依赖，可能是由于使用“barrel” index.ts 文件引起的”。于是我检查项目中的 provider 使用没有问题，检查了各个模块之间的依赖也没有问题，注意到项目中写了很多index.ts文件，咋一看没有什么问题，比较难发现，但是仔细看index的引用发现barrel使用时有些坑需要注意。 Barrel先介绍一下Barrel，barrel是将多个模块的导出汇总到一个模块的一种方法。barrel本身是一个模块文件，可以重新导出其他模块的选定导出。 例如有三个模块123456789101112131415161718// heroes/hero.component.tsexport class HeroComponent &#123;&#125;// heroes/hero.model.tsexport class Hero &#123;&#125;// heroes/hero.service.tsexport class HeroService &#123;&#125;// index.tsexport * from './hero.model.ts'; // re-export all of its exportsexport * from './hero.service.ts'; // re-export all of its exportsexport &#123; HeroComponent &#125; from './hero.component.ts'; // re-export the named thing// used barrelimport &#123; Hero, HeroService &#125; from '../heroes'; // index is implied// without barrelexport &#123; Hero &#125; from '../heroes/hero.model.ts';export &#123; HeroService &#125; from '../heroes/hero.service.ts'; Barrel的坑在导入同一个模块中的文件时使用barrel可以让文件看起来更清爽，但是在使用时需要注意，因为使用不当可能会引起循环依赖。在这个DQC这个项目中，依赖了@datapi/dscomponent这个包，包在本地打包没问题，但是发成npm包被项目引用后，项目打包就报上面的错误。我简化下，还原报错原因。 目录结构：|—service|—|—a.service.ts|—|—b.service.ts|—|—index.ts|—table|—|—…|—|—table.module.ts 例如如下使用1234567891011121314// a.service.tsexport class AService &#123; &#125;// index.tsexport * from './a.service.ts';export * from './b.service.ts';// table.module.tsimport &#123; AService &#125; from '../service';@NgModule(&#123; ... providers: [AService]&#125;)export class TableModule &#123; &#125; import { AService } from &#39;../service&#39;; 改为 import { AService } from &#39;../service/a.service.ts&#39;; 后问题得到解决 angular风格指南angular团队已经不推荐barrel这种写法，在风格指南已经删除相关写法。 所以删除项目中的barrel，改为具体文件导入。 参考文章Angular DI Error - EXCEPTION: Can’t resolve all parametersBarrel and Circular dependency","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]},{"title":"表格固定表头和固定列","slug":"表格固定表头和固定列","date":"2019-01-12T08:26:52.000Z","updated":"2019-01-15T01:47:31.611Z","comments":true,"path":"2019/01/12/表格固定表头和固定列/","link":"","permalink":"https://wangcherry.github.io/blog/2019/01/12/表格固定表头和固定列/","excerpt":"","text":"平时业务中经常会碰到固定表头或者固定列的需求，对于只固定表头或者固定列的情况可以使用两个表格，利用css实现。但是对于需要同时固定表头和列的情况，就需要四个表格完成样式，js监听滚动事件。如果表格数据比较多，样式复杂，性能就会受影响，效果不是很理想。那么，我们还有其他方式实现同时固定表头和列吗？ 答案是，yes 接下来给大家介绍下 position: sticky; 这个属性 position属性CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。position 常用值有： absolute（生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。） relative（生成相对定位的元素，相对于其正常位置进行定位。） fixed（生成固定定位的元素，相对于浏览器窗口进行定位。） sticky（生成粘性定位元素） 下面我们主要介绍的是粘性定位 粘性定位属性为 position: sticky 的元素是粘性定位元素。 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。举个栗子： git效果图： dt元素在到达顶部之前为相对定位，当元素的top为0之后，就固定在顶部。 查看源码 position: sticky; 实现表格固定表头和列一个表格轻松搞定表头和列固定 gif效果图： 查看源码 需要注意： 该粘性定位元素并不脱离文档流，仍然保留元素原本在文档流中的位置。 当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。 兼容性： 这个属性的兼容性还不是很好，目前仍是一个试验性的属性，并不是W3C推荐的标准。查看兼容性 js实现表格固定表头和列对兼容性要求高时可以考虑用js监听滚动实现固定 gif效果图： 查看源码","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wangcherry.github.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://wangcherry.github.io/blog/tags/css/"},{"name":"js","slug":"js","permalink":"https://wangcherry.github.io/blog/tags/js/"}]},{"title":"文件下载和页面打印","slug":"文件下载和页面打印","date":"2018-12-27T05:58:10.000Z","updated":"2019-03-04T07:04:30.190Z","comments":true,"path":"2018/12/27/文件下载和页面打印/","link":"","permalink":"https://wangcherry.github.io/blog/2018/12/27/文件下载和页面打印/","excerpt":"","text":"文件下载和页面打印在业务中有很多使用场景，它们的本质是一样的，都是向后端发一个请求，然后后端返回一个文件。浏览器将文件下载下来，（打印的情况，就是返回html文件，文件加载完之后调浏览器的打印）。 下面主要从文件下载讨论： 使用 a 标签最基础的用法，加 download 属性，浏览器下载该文件。缺点： 不能使用post方法 不能在启动下载时禁用按钮、下载完毕启用按钮1&lt;a href=\"/xhr/doc/ts实践总结&amp;ts解析.pptx\" download&gt;下载&lt;/a&gt; 关于 download 重命名 download 的值可作为文件的名称 后端如果对文件命名，那么会使用后端的命名 在后端没有命名时，以 download 的值为文件名称 都没命名时，或者 download 值设置为空时，下载的文件用文件本身的名称 window.open缺点： 异步回调函数里调 window.open 会被浏览器拦截12345678/** * 下载方法 * @param url * @param target */export const windowOpen = (url: string, target: string = '_blank') =&gt; &#123; window.open(url, target);&#125; 动态创建 a 标签如果在某些业务操作之后再下载的情况，就可以动态创建一个 a 标签。12345678910111213141516/** * 下载方法 * @param url * @param target */export const download = (url: string, target: string = '_blank', fileNmae: string = '') =&gt; &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target; a.download = fileNmae; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a);&#125;; iframe + form 不管是 a 标签还是 window.open ，在异步回调里都可能会被浏览器拦截（具体看浏览器，因为不是用户发起的页面跳转，有些浏览器会认为不安全） 或者是下载请求需要带复杂对象参数，需要用 post 方法，可以使用 iframe + form 利用表单的形式带参数。1234567891011121314151617181920212223242526272829303132333435363738/** * 下载方法 * @param url * @param target */export const download = (url: string, params: any) =&gt; &#123; const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125;&#125;; 使用 fetch 完成下载 对于 post 请求后端直接返回文件流的情况，可以使用 fetch 下载。 更多 Fetch 知识请查看MDN123456789101112/** * 下载方法 * @param url * @param target */ export const downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); ... // 动态创建 a 标签完成 &#125; DEMO源码html：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;p&gt;1：点击 下载 来下载文件：&lt;p&gt;&lt;p&gt;a 标签 &lt;a href=\"/xhr/doc/test.pptx\"&gt;下载&lt;/a&gt;&lt;/p&gt;&lt;p&gt;window.open 下载 &lt;button onclick=\"windowOpen('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;动态创建 a 标签 &lt;button onclick=\"createAEle('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;异步请求回调里下载 &lt;button onclick=\"downloadAfterAsync();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;ajax回调里下载 &lt;button onclick=\"downloadAfterAjax();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;form 表单提交 &lt;button onclick=\"formDownload('/xhr/doc/test.pptx',&#123;a:1,b:2&#125;);\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;使用fetch下载 &lt;button onclick=\"downloadByFetch();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function windowOpen(url) &#123; window.open(url,'_blank'); &#125; function createAEle(url, target, fileName) &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target || '_target'; a.download = fileName ? fileName : undefined; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a); &#125;; function downloadAfterAsync() &#123; const http = new XMLHttpRequest(); http.open('GET','/xhr/get/url.json'); http.send(); http.onreadystatechange = () =&gt; &#123; if(http.readyState === 4 &amp;&amp; http.status === 200) &#123; const url = http.responseText; // createAEle(url); // 有些浏览器，动态创建表单也会拦截 // windowOpen(url); // 异步回调里调用，浏览器会拦截 formDownload(url); // 不拦截 &#125; &#125; &#125; function downloadAfterAjax() &#123; $.ajax(&#123; method: 'GET', url: '/xhr/get/url.json', async: false // 将异步改为同步，浏览器不拦截 &#125;).done(url =&gt; &#123; windowOpen(url); &#125;); &#125; function formDownload(url, params) &#123;// 可以使用post方法，携带大对象参数 const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125; &#125; async function downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); createAEle(url, '_target', 'a.pptx'); &#125;&lt;/script&gt; server：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const Koa = require('koa');const path = require('path');const fse = require('fse');const static = require('koa-static');const opn = require('opn');const Router = require('koa-router')const bodyParser = require('koa-bodyparser');const app = new Koa();const router = new Router();const returnFile = async (ctx, next) =&gt; &#123; console.log(ctx.request.body);// post 方法提交的参数 let filePath = decodeURI(ctx.path.replace('/xhr/', '')); if (fse.existsSync(path.resolve(filePath))) &#123; ctx.set('Content-disposition', 'attachment; filename=a.pptx'); ctx.set('Content-Type', 'application/vnd.openxmlformats-officedocument.presentationml.presentation; charset=UTF-8'); console.log(path.resolve(filePath)) ctx.body = fse.readFileSync(path.resolve(filePath)); &#125; else &#123; console.log('error'); await next(); &#125;&#125;// 配置静态资源app.use(static( path.join(__dirname, './src')))// 使用ctx.body解析中间件app.use(bodyParser())// 请求router.get('/xhr/doc/:name', returnFile)router.post('/xhr/doc/:name', returnFile)// 请求router.get('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)router.post('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)app .use(router.routes()) .use(router.allowedMethods());opn('http://localhost:3001/');app.listen(3001);","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]}]}