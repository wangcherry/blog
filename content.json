{"meta":{"title":"小英英的博客","subtitle":null,"description":"越努力越幸运~","author":"小英英","url":"https://wangcherry.github.io/blog"},"pages":[],"posts":[{"title":"严选工程化实践","slug":"严选工程化实践","date":"2019-12-24T09:30:50.000Z","updated":"2020-03-06T03:04:01.050Z","comments":true,"path":"2019/12/24/严选工程化实践/","link":"","permalink":"https://wangcherry.github.io/blog/2019/12/24/严选工程化实践/","excerpt":"","text":"前端日益发展，从最初的 HTML、CSS、JavaScript 三大基础，到后来的jQuery、Backbone、AngularJS，再到现在的 Angular、React、Vue 三大框架流行，技术的演进既带来了更多的可能，也带来了一些问题。例如：团队如何高效合作、项目如何统一维护、代码如何规范等等。前端工程化的出现，就是为了解决这些日益突出的问题。它旨在制订规范化的前端工作流，并规范统一项目的模块化开发和前端资源，让代码的维护和互相协作更加容易更加方便。 今年我们团队由 angular 技术栈转变成 react 技术栈，在这个大背景下，我们急需一套完善的工程化方案来帮助技术栈落地。在通过确定目标、定义规范、技术调研、开发实现等一系列步骤之后，制定了一套完善的工程化方案。它帮助解决开发流程中的问题，让开发更加专注业务本身，提高整个系统生产效率。 1. 目标定义作为一个工程化方案，最终的目标是尽可能解决项目生命周期里遇到的问题，例如： 规范保障 每个团队都会根据实践经验，总结出一套自己的规范（项目规范和流程规范）。让这一套规范在落地到实际的开发中时，除了人为的约束，更多的应该是通过工具约束。工程化就是把团队的经验沉淀到脚手架和开发套件中，让新项目或新成员可以复用这些经验。 提效 一个好的工程化方案，是可以提升开发效率的，这个提效包括初始化项目，完备项目的dev环境，数据mock，build打包等一系列流程，既要让项目“搭建-开发-部署”更快捷高效，也要方便项目的后期维护和迭代。 减少人力 在开发过程中可能会遇到一些重复人力的工作。例如A、B两个系统有一个相似的列表页，这个列表页不能作为组件抽离，但是又在多处能用到，这部分资源（代码模板）复用急需一个中间媒介来完成。 假如资源/项目需要升级了，大多情况是资源开发者出一个升级文档，然后升级的人按照文档一步步修改。这是很重复的一份工作，因为假如你手上有十个项目，你就需要把相同的事情做十遍，这一步重复的工作我们希望可以通过工具来完成。 同时，我们的工程化方案应该符合以下四个特点： 渐进式（技术演化能力）易于迭代 扩展性（可伸缩、可插拔）易于部门共建 易用性（贴合实际）易落地 数据统计与分析 2. 方案设计基于以上的目标，下面来看一下整个工程化的方案设计。 首先，介绍整个方案的架构图： 2.1 架构图可以看到整个架构图分为四层： 2.1.1 底层依赖最底层依赖了规范、webpack、schematics、node、eslint，它是上次架构的基石。 规范这里包括了项目规范和流程规范，是整套方案需要遵守的约定； 因为这套规范是根据大量的实际业务总结出来的，所以它是贴合业务场景，便于整体方案落地的。 schematics 引入主要是为了解决上面说到的资源相关的问题，后面会详细讲到。 2.1.2 插件封装层这一层主要是对上层需要实现的功能做一个划分，然后通过插件的形式实现。例如： 将一系列模板抽离作为一个集合，然后将项目初始化时需要做的模板选择和模板处理放到 init 插件中完成，不同团队可以根据规范自定义插件； 开发编译阶段需要的 webpack 和 server、build 脚本放在 @sharkr/scripts 插件中完成，不同团队可以根据规范自定义插件； 前面说到的资源复用和资源升级问题，统称为文件处理相关，@sharkr/schematics-cli 插件提供这个能力； @sharkr/eslint-config-react 插件提供 eslint 检查； 还有一部分公共能力封装成 util 插件，方便共享。 这种插件的方式可以使工具具有很强的扩展性，在跟其他团队共建时，可以很方便的做一些自定义，但是又符合统一的规范。 2.1.3 统一命令层第三层是统一命令层，这一层做的事情就是，最终对用户暴露一个统一的工具 @sharkr/cli ，在 cli 里去规范常用的一些命令，当然这些命令的具体实现都是调用下一层的插件。这些命令会应用到项目开发的生命周期中去。 在这一层中会添加埋点，用于收集命令、项目、使用包等相关情况，以便做数据的统计与分析，了解实际落地情况，也为未来迭代版本提供有效参考。 2.1.4 项目生命周期项目生命周期，就是指项目从初始化，到开发（或后期迭代），再到CICD的这么一个周期。可以看到下一层的命令大多都可以对应到项目生命周期中，例如： init 完成项目初始化 dev 可以使开发者快速的进入开发 add 可以给项目增加一个资源 generate 可以执行资源里定义的命令 update 帮助快速升级资源 lint 编码规范校验 test 对开发过程中的代码做一个测试 build 在CI阶段可以帮助完成编译打包 通过这整个架构可以看到，我们的工具可以介入到项目生命周期里的所有环节，那么这些环节有的一些问题和痛点，也可以通过工具去解决。下面将会从项目生命周期的角度讲解一下我们工程化的一个具体方案。 2.2 项目初始化首先，在项目初始化过程中需要解决的一个问题就是：帮助规范落地。 把规范分为项目规范和流程规范，流程规范上面也介绍了，通过工具做了一个约束，那么项目规范怎么在初始化的时候落地呢？ 我们的做法是，将这部分规范落地到模板当中，用户通过 @sharkr/cli 去 init 项目，选择合适的模板，init 插件完成模板处理，然后就初始化了一个符合规范的项目。 这里提到选择合适模板，init 插件完成模板处理，那 init 插件是怎么做的呢？ 2.2.1 init 插件每个团队都会有一些常用的业务场景，例如我们B端，会维护好几个模板，纯 web 的、带 node server 的、应用于微应用的，那么这一系列模板作为一个集合，配套的会出一个相应的 init 插件，这个插件可以完成这系列模板的初始化处理。 执行 init 命令时，cli 调用对应的 init 插件，用户根据提示输入项目相关配置项，init 插件根据配置项处理模板。 假如说其他团队也有自己的模板，那么同样的，他们也可以根据规范提供模板配套的 init 插件供 cli 调用，方便共建。 这是插件的一个优势，可以方便扩展自定义的部分，但是它也带来了一个小问题。这部分插件不是很稳定，可能经常需要更新，它的频繁更新会给用户带来影响。这就需要有一个较好的插件更新机制，方便迭代。 2.2.2 插件更新先来看一下最初采用的插件更新机制，如下图： 用户执行 sr init myapp，调用 @sharkr/cli @sharkr/cli 检查 init 插件版本 发现版本不是最新的，提示用户 update @sharkr/cli 用户全局 update @sharkr/cli 再次执行 sr init myapp, 调用 @sharkr/cli @sharkr/cli 调用最新的 init 处理 这种方式需要用户经常手动更新，不是很友好，所以在后来方案设计时，改用了 npx 的方式调用 init 插件 npx 是 npm5.2 版本中新增的命令，它能临时下载一个模块并且运行它，运行之后再删除这个模块 用户执行 sr init myapp，调用 @sharkr/cli @sharkr/cli 使用 npx 调用最新的 init 插件处理 通过方案二，可以看到使用 npx 的方式调用插件，可以使用户在任何时候使用 init 命令都能调用最新的 init 插件完成项目初始化。 说完了项目初始化，再来看一下开发/迭代过程中会遇到哪些问题。 2.3 开发/迭代完成项目初始化进入开发阶段，这个阶段应该是关注业务本身、减少重复工作、高效快速的。 2.3.1 dev 环境开始项目开发遇到的第一个问题就是 dev 环境。需要 webpack 配置编译代码、需要一个本地 server、需要一个数据转发、需要 eslint 配置规范编码等。 这一部分可以通过 @sharkr/scripts 提供 webpack 配置和 server 脚本，在模板里集成调用，用 koa 起一个本地服务，koa 中间件完成转发等。@sharkr/eslint-config-react 定义编码规范。在这个环节规范了流程和配置，有效的保障项目质量。 有了一个完备的 dev 环境，再来看一下前面说到的资源复用和资源/项目升级。 2.3.2 资源复用和资源/项目升级资源复用简单把资源分为两类，一类是有固定输入输出，可抽离的，例如时间控件，下拉列表等；还有一类是无固定输入输出，不可抽离，但是又具有某些共性的，例如B端常见的列表页、详情页，这一部分资源没有一个很好的复用方式。 对于第一类资源，可以采用封装组件的形式完成资源共享： 对于第二类资源，以前的做法基本是 Ctrl+c、Ctrl+v 来复用，这种做法不够高级，还效率不高，所以在 cli 中提供了另外一种做法，那就是将代码模板抽离到一个 schematic 包里，然后通过 @sharkr/cli 来安装这个包，并且执行里面的 schematic。 资源/项目升级同样的，假如项目或者是资源需要升级，就需要在项目中升级依赖，可能还需要修改配置、甚至调整目录结构、修改api调用等。这种升级以前的做法是，出一份升级文档，升级者按照文档一步步修改项目完成升级。假如有几十个项目，就需要几十个人做相同的事几十遍，这无疑是一个大的人力消耗，作为一个提效工具，就是需要将这部分重复的工作通过代码完成。 把升级文档里做的事情编写成 schematic 包 通过 @sharkr/cli 来安装这个包，并且执行里面的 schematic 这么一看，好像很简单，不管是资源复用，还是项目升级，都写成 schematic 包就好了，那么schematic到底是什么呢？ 2.3.3 schematics简介schematics 是 ngCli 团队开发的一个强大和通用的工作流程工具，开发者可以将变换应用于项目中，例如：创建新组件、添加配置项、修改现有项目，或者更新你的代码来修复更新依赖时带来的 break change。 原理schematics 如它名字一样，可以理解为一个描述了具体操作的原理图。 schematics 的输入是一个树，包含一个基础区域（一组已经存在的文件）和一个临时区域（要应用于基础区域的更改列表）），schemtics 描述了对 Tree 的修改，并将这些修改合并到临时区域的更改列表中，再往外输出一个新的 Tree。 在整个操作完结，并得到确认后，链条中所有描述的修改才会真正被应用。 更多schematics知识&gt;&gt; 优势和常规的js脚本工具相比，它的优势在哪呢？ 开发便捷 提供了丰富而强大的通用能力，帮助开发者快速开发：在 code generate 领域，可以通过使用其模板能力，构建各种类型的动态场景代码模板，快速生成代码。同时还提供了丰富的 util，提供包括 ast、git 初始化、TslintFixTask tslint 处理等能力。 易于调试 schmatics 由于其虚拟树的设计，在开发阶段支持干运行，并不会对文件系统执行任何直接操作，方便开发者在项目中进行调试，安全无污染。 可扩展性和可重用性 从其原理可以看出，schmatics 的整体设计，遵循了函数式范式，schematics 不会产生副作用（副作用只会被记录在缓存区中），具备原子性。schematics 可以自由 Compose 成新的 schematics。 测试友好 schmatics 提供了完备的测试支持库，测试用例书写没有障碍。 schematics 封装既然 schematics 处理文件很友好，而且刚好能解决文件处理问题，于是我们就引入了 schematics 完成文件处理，并对它做了一层封装。 最底层主要依赖 @angular-devkit/schematics 和 @angular-devkit/core 提供 schematics 基础能力； 将公共能力提取到 @schematics/util 方便开发调用； 提供 schematics 开发模板，方便开发新建 schematics 包；封装 schematics 的 cli，也就是说它也可以单独调用命令； 资源（通用资源、项目改造资源、模板升级资源等）会做一些整合，这些资源集合将作为物料维护在物料海，将来会跟我们正在开发的物料平台对接； 向上暴露所有的命令，最终在 @sharkr/cli 作为统一出口。 下面再来看下，开发和使用一个 schematics 包需要做点什么呢？ 首先，对于开发者来说，需要做以下三步： 根据 schematics 规范开发一个 schematics 包 定义配置项（可选） 定义 schema 命令 其次，对于用户来说，需要做以下三步： 使用 @sharkr/cli 调用 schematics 包 输入配置（可选） 完成项目修改 那么 @sharkr/cli 做了什么了？ @sharkr/cli 调用 @sharkr/schematics 插件 schematics 插件解析出自定义配置项，生成用户会话 根据用户会话拿到 option，传入 option 调用 Rule 函数 修改文件放到暂存区 确认修改后更新物理文件 这里 Rule 函数是需要开发者实现的，任何你想写成文档的都能通过代码方式写在这个 Rule 函数里。 schematics 实践下面来看一个实际的例子：前段时间我们的项目都需要完成服务上云，为了实现上云，需要调整下CI脚本，还要往项目里放一些环境配置文件，涉及到多处文件修改和增加，所以我们写了一个 @sharkr/ng-cloud-add 的 schematics 包达到快速改造项目的目的。以下是效果： 核心代码写起来跟写文档类似： 以上就讲完了在开发/迭代过程中遇到的问题和解决方案，最后再看一下CICD阶段做了什么 2.4 CI这部分跟 dev 环境类似，也需要提供 webpack 配置、build 脚本、还约束了 build 打包后的目录规范、配置部署相关文件。 3. 价值与后续计划3.1 价值通过介绍以上的一些方案设计，可以发现这套工具可以让开发更专注业务本身，初始化项目之后就可以直接进入开发；重复的Ctrl+c、Ctrl+v可以通过 schematics 完成，省去重复的人力成本；项目/资源升级可以更加快速推进；规范和文档沉淀到工具中供使用，非常有利于规范的遵守。 3.2 后续计划接下来长远的规划将会从以下两点展开： 与资源平台结合。目前放在 schematics 包里的资源没有一个很好的展示平台，后续将会对接正在开发的物料平台，让资源更容易被共享。 vscode 可视化扩展能力。为了让开发在开发过程中更加快捷高效，后续会结合 vscode 的插件能力，让添加资源更容易。 4.总结本篇分享主要从四个方面对工程化实践做了一个阐述： 开发规范的落地依赖模板收敛项目规范，cli 工具收敛流程规范的方式，并在初始化项目时将模板应用于实际项目场景。 cli 工具的扩展依赖于插件式，对于自定义的部分提供相应插件即可扩展，而插件的更新依赖 npx 调用的方式，解决用户需要频繁更新问题。 方便快速初始化项目，提供完备的 dev 环境和 build 脚本等提升了开发效率。 资源复用和资源/项目升级统称为文件处理，这部分借用了 angular 里的 schematics 功能来完成。在这部分还讲了什么是 schematics 以及它在 cli 里做了什么。 以上。","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"},{"name":"cli","slug":"cli","permalink":"https://wangcherry.github.io/blog/tags/cli/"},{"name":"方案设计","slug":"方案设计","permalink":"https://wangcherry.github.io/blog/tags/方案设计/"}]},{"title":"大量数据列表不卡顿的秘密","slug":"大量数据列表不卡顿的秘密","date":"2019-12-14T07:33:12.000Z","updated":"2020-04-13T06:46:52.098Z","comments":true,"path":"2019/12/14/大量数据列表不卡顿的秘密/","link":"","permalink":"https://wangcherry.github.io/blog/2019/12/14/大量数据列表不卡顿的秘密/","excerpt":"","text":"大量数据列表之前在开发一个账号选择器的需求时，遇到过账号非常多（30w+）而且交互上有一些级联勾选、搜索等复杂操作，所以这30w+的账号必须在前端维护。账号有组织架构关联，所以它是一个tree结构，可以全部展开。账号多接口返回也慢，刚开始时全部渲染出来，带来的问题是页面很卡，尤其是滚动的时候，能卡好几秒不动。 接口优化由于接口一下返回的数据多，也是有点慢的，所以第一步就是找后端一起优化接口。去掉冗余字段、简化字段名称、压缩返回数据。效果很好，接口返回快了很多。 样式优化由于是tree结构，有很多的位置样式，导致页面渲染时计算费事，这块就尽量减少重排和重绘。 虚拟滚动做了以上两步之后页面卡顿好了一些，但是渲染那么多DOM依旧无法使用流畅，后来看到一个虚拟滚动的文章受到启发。原理很简单，就是设置容器的高，并且不直接渲染所有DOM，只渲染可视范围内的元素。元素在容器内滚动时再监听滚动并往可视范围内插入和移除DOM。如此不管是有多少账号绝对不会卡顿。 为了方便学习，我写了一个非常简单的例子，在这个例子里可视范围内每次滚动全部渲染了，实际应该定上下两个浮标，动态插入和移除元素。查看源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;monaco&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; box-sizing: border-box; &#125; .monaco-scrollable-element &#123; width: 200px; height: 500px; overflow-y: auto; border: 1px solid #d9d9d9; margin: 20px auto; box-sizing: content-box; &#125; .monaco-list-rows &#123; position: relative; &#125; .monaco-list-rows .monaco-list-row &#123; height: 20px; line-height: 20px; position: absolute; left: 0; width: 100%; padding: 0 20px; &#125; .monaco-list-rows .monaco-list-row:hover &#123; background-color: #fafa; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"monaco-scrollable-element\"&gt;&lt;/div&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; (() =&gt; &#123; const originArr = []; const viewH = 500; const itemH = 20; const monacoScrollableElement = $('.monaco-scrollable-element'); for (let index = 0; index &lt; 1000000; index++) &#123; originArr.push(index); &#125;; updateView(0); function updateView(currTop) &#123; if(currTop + viewH &gt; originArr.length * itemH) return; const activeArr = originArr.slice(Math.floor(currTop/itemH), Math.floor((currTop + viewH)/itemH)); const lis = monacoScrollableElement.find('li.monaco-list-row'); const monacoListRows = $('&lt;ul class=\"monaco-list-rows\"&gt;&lt;/ul&gt;'); for(i = 0; i &lt; activeArr.length; i++) &#123; if(lis.length === 0) &#123; monacoListRows.css(&#123;'height': originArr.length * itemH&#125;); const li = $(`&lt;li class=\"monaco-list-row\"&gt;$&#123;activeArr[i]&#125;&lt;/li&gt;`); li.css(&#123;'top': currTop + itemH * i + 'px'&#125;); monacoListRows.append(li); &#125;else &#123; const li = lis.eq(i); li.text(activeArr[i]); li.css(&#123;'top': currTop + itemH * i + 'px'&#125;); &#125; &#125; lis.length === 0 &amp;&amp; monacoScrollableElement.append(monacoListRows); &#125; monacoScrollableElement.scroll(e =&gt; &#123; updateView(e.target.scrollTop); console.log('scrollTop: ',e.target.scrollTop) &#125;) &#125;)() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wangcherry.github.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://wangcherry.github.io/blog/tags/css/"},{"name":"js","slug":"js","permalink":"https://wangcherry.github.io/blog/tags/js/"}]},{"title":"nodejs开发CLI工具","slug":"nodejs开发CLI工具","date":"2019-09-25T01:34:34.000Z","updated":"2019-12-31T09:19:52.169Z","comments":true,"path":"2019/09/25/nodejs开发CLI工具/","link":"","permalink":"https://wangcherry.github.io/blog/2019/09/25/nodejs开发CLI工具/","excerpt":"","text":"在没有@vue/cli、create-react-app、@angular/cli这样子的脚手架时你是否遇到过一个文件一个文件的去拷贝老项目的配置文件？在开始使用脚手架后是否发现当前的脚手架不能完全贴合实际的业务场景？最近，我们组由angular框架转换成react框架，开发了一套完整的cli工具。写下这篇文章作为一个记录，希望大家看到后都能实现一个属于自己的脚手架工具。 CLI（command-line interface，命令行界面）是指可在用户提示符下键入可执行指令的界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。 准备工作主要分为以下几步： 新建一个项目并初始化package.json 开发前准备 获取参数 新建一个项目并初始化package.json12mkdir cli &amp; cd clinpm init 在package.json里配置命令，bin项用来指定各个内部命令对应的可执行文件的位置。这里 sr 就是我的命令了123\"bin\": &#123; \"sr\": \"./bin/index.js\"&#125; 开发前准备在bin文件夹下创建一个index.js ./bin/index.js123#!/usr/bin/env nodeconsole.log('my cli！'); 将命令链接到全局：1npm link 执行命令后，my-cli会根据package.json上的配置，sr 命令被链接到全局。更多npm link知识 这时在任何目录执行 sr 将会看到： 到这里就可以开始开发 cli 了，./bin/index.js 的更改会实时同步到全局命令的。 获取参数有了命令，那么具体子命令怎么执行呢？例如我输入 sr info 时希望能打印当前环境信息。效果如下： 首先，我们需要获取参数，因为知道是 info 命令，才能执行打印环境信息操作。那么怎么获取命令行参数呢？下面介绍用原始方法和使用模块获取命令行参数： 原始方法获取命令参数命令行参数可以用系统变量 process.argv 获取。（打印当前环境信息用 envinfo） ./bin/index.js123456789101112131415161718192021222324#!/usr/bin/env nodeconst envinfo = require('envinfo');if(process.argv[2] === 'info' ) &#123; envinfo .run( &#123; System: ['OS', 'CPU'], Binaries: ['Node', 'Yarn', 'npm'], Browsers: ['Chrome', 'Edge', 'Firefox', 'Safari'], npmPackages: ['envinfo'], npmGlobalPackages: ['@sharkr/cli'], &#125;, &#123; showNotFound: true, duplicates: true, fullTree: true, &#125; ) .then(console.log);&#125;else &#123; console.log('my cli！')&#125; 使用模块commander获取命令参数commander这个模块是node.js命令行界面的完整解决方案，不仅有着强大的参数解析功能，还提供了用户命令行输入，是cli开发的一个很好选择。 ./bin/index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env nodeconst envinfo = require('envinfo');const program = require('commander');program .version(require('../package').version) .usage('&lt;command&gt; [options]');program .command('info') .description('Print debugging information about your environment') .option('-s, --show-not-found', 'show not found package') .action((cmd) =&gt; &#123; const options = cleanArgs(cmd); console.log(options) envinfo .run( &#123; System: ['OS', 'CPU'], Binaries: ['Node', 'Yarn', 'npm'], Browsers: ['Chrome', 'Edge', 'Firefox', 'Safari'], npmPackages: ['envinfo'], npmGlobalPackages: ['@sharkr/cli', 'xxx'], &#125;, &#123; showNotFound: options.showNotFound, duplicates: true, fullTree: true, &#125; ) .then(console.log); &#125;);program.parse(process.argv);function camelize(str) &#123; return str.replace(/-(\\w)/g, (_, c) =&gt; (c ? c.toUpperCase() : ''));&#125;function cleanArgs(cmd) &#123; const args = &#123;&#125;; cmd.options.forEach(o =&gt; &#123; const key = camelize(o.long.replace(/^--/, '')); if (typeof cmd[key] !== 'function' &amp;&amp; typeof cmd[key] !== 'undefined') &#123; args[key] = cmd[key]; &#125; &#125;); return args;&#125; command：子命令 description：命令描述 option：配置项 action：命令对应要执行的方法 cleanArgs 函数将 option 处理成键值对，方便使用 program.parse(process.argv) 解析命令参数 init命令经过上面的准备工作，cli 已经可以获取命令和参数了，那么接下来就可以开始写命令对应的操作了。作为项目的脚手架，第一步当然是初始化一个项目。分为以下两步完成： 准备模板 编写init命令 准备模板我们的模板都放在 gitlab 维护，init 时从 gitlab clone，这么做主要是考虑到我们模板比较多，且前期模板不稳定，避免模板更新时需要频繁更新 cli。多个模板可以通过配置项来选择。 编写init命令以下是省去很多校验和兼容处理的一个init命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546program .command('init &lt;app-name&gt;') .description('Init a new react project') .option('-t, --type &lt;type&gt;', 'Set template type') .option('-y, --useYarn', 'Use yarn install (default use npm)') .action(async (appName, cmd) =&gt; &#123; const options = cleanArgs(cmd); // 获取代码前可以进行一些特性对话 let templateGit; if (options.type) &#123; // 虚构的git模板地址 templateGit = `git@github.com:sharkr/react-template/$&#123; options.type &#125;.git`; &#125; else &#123; const &#123; type &#125; = await inquirer.prompt([ &#123; name: 'type', type: 'list', message: `Select template type:`, choices: [ &#123; name: 'full, include server &amp; web', value: 'full' &#125;, &#123; name: 'web, only web template', value: 'web' &#125;, &#123; name: 'npm, include server &amp; web for package', value: 'npm' &#125; ], default: 'full', &#125;, ]); // 虚构的git模板地址 templateGit = `git@github.com:sharkr/react-template/$&#123;type&#125;.git`; &#125; // clone代码 execSync(`git clone $&#123;templateGit&#125; $&#123;appName&#125;`, &#123; stdio: 'ignore' &#125;); const appPath = path.resolve(appName); process.chdir(appPath); fse.removeSync(path.join(appPath, '.git')); // 这里可以对模板做一下处理 // 根据配置项install if(options.useYarn) &#123; spawn('yarn', ['install'], &#123; stdio: 'inherit' &#125;); &#125;else &#123; spawn('npm', ['install'], &#123; stdio: 'inherit' &#125;); &#125; &#125;); 执行 sr init my-app init 命令提供一个配置项 type 设置需要拉取的模板类型，我们可以执行 sr init my-app 初始化项目，没设置 type 时需要选择模板类型。执行 sr init my-app -t full 时直接拉取full模板。在实际开发中，可以根据模板的用途做更多的特性选择和处理。 小结：在命令行工具的开发过程中，使用commander、inquirer和chalk等一些npm插件，可以很好的完成命令行工具的开发，并且可以达到很棒的效果，感兴趣的话，赶快试试吧，做一款自己的命令行工具。","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"},{"name":"cli","slug":"cli","permalink":"https://wangcherry.github.io/blog/tags/cli/"}]},{"title":"nodejs实现http和https代理服务","slug":"nodejs实现http和https代理服务","date":"2019-04-30T02:22:55.000Z","updated":"2019-12-31T09:26:54.495Z","comments":true,"path":"2019/04/30/nodejs实现http和https代理服务/","link":"","permalink":"https://wangcherry.github.io/blog/2019/04/30/nodejs实现http和https代理服务/","excerpt":"","text":"http/https协议作为一个程序员，我们经常会使用到代理，例如将本地请求转到测试环境以完成联调；或将某些请求转发到指定服务器等。那么代理转发的实现原理是什么呢？下面将介绍nodejs如何实现http和https代理服务。 关于HTTP和HTTPS协议： HTTP(Hypertext Transfer Protocol，超文本传输协议) 在OSI七层模型属于应用层协议，在网络与传输层使用可靠的数据传输协议TCP/IP，HTTP协议采用明文传输信息的方式。 HTTPS (Secure Hypertext Transfer Protocol，安全超文本传输协议）是一个安全通信通道，基于HTTP开发，用于在客户端和服务器之间交换信息时采用安全套接字层(SSL)进行信息交换。通俗地讲，HTTPS是HTTP的安全版，即使用了TLS/SSL加密的HTTP协议。 http/https代理原理下面主要介绍两种代理实现，一种是“中间人”代理（《http权威指南》第六章），还有一种是隧道代理（《http权威指南》第八章） “中间人”代理MITM（中间人）代理在实际开发和测试中经常会使用。调试接口、查看HTTP请求与响应时使用的http抓包调试工具如：Fiddler、 Charles，就是基于该原理实现的。用户通过设置代理，网络请求就会通过中间人代理，再发往正式服务器。 所以我们的实现原理就是建立一个可以同时与客户端和服务端进行通信的网络服务。 中间人代理示意图（来源于《HTTP权威指南》）： HTTP客户端会向代理发送请求报文，代理服务器必须像Web服务器一样，正确的处理请求和连接，然后返回响应。同时，代理自身要向服务器发送请求，这样，其行为就必须像正确的HTTP客户端一样，要发送请求并接受响应。 那么http代理的实现方案就是： 此时的代理就是“中间人”，代理拦截到请求之后可以修改请求数据，再向服务器发起请求，获取到数据后也可以修改数据，再返回给客户端。当然，代理也可以不向服务器发起请求，而是直接返回本地的数据，那就是数据mock。 用node运行下面代码（注意需要设置开启代理）12345678910111213141516171819202122232425262728const http = require('http');const url = require('url');function request(req, res) &#123; const u = url.parse(req.url); const options = &#123; hostname : u.hostname, port : u.port || 80, path : u.path, method : req.method, headers : req.headers &#125;; const proxyReq = http.request(options, function(proxyRes) &#123; console.log('http proxy：' + options.hostname); res.writeHead(proxyRes.statusCode, proxyRes.headers); proxyRes.pipe(res); &#125;).on('error', function(e) &#123; res.end(); &#125;); req.pipe(proxyReq);&#125;const proxy = http.createServer(request);proxy.listen(8888); 隧道代理上面已经完成了HTTP代理，那么是不是将HTTP换成HTTPS就能实现HTTPS代理呢？答案是不能，首先我们来看下HTTP和HTTPS去区别： 从上图可以知道HTTPS的分层是在传输层之上建立了安全层，所有的HTTP请求都在安全层上传输。所以对于http代理，我们只需要拦截请求，就可获取到报文信息从而完成转发。但是对于https请求，我们无法获取安全层数据。更多SSL/TLS协议知识可以参考SSL/TLS协议运行机制的概述 那么我们如何转发HTTPS流量呢。方法就是在客户端和服务器之间建立一条Web隧道。Web隧道用HTTP的CONNECT方法建立起来的。 CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。这种方法不仅能代理HTTPS请求，理论上可以代理所有基于TCP协议的请求。不过HTTP流量代理会耗费一次TCP连接，所以默认HTTP流量不走隧道代理。 下图显示了CONNECT方法如何建立一条到达网关的隧道（来源于《HTTP权威指南》）： 那么隧道代理的实现方案就是： 第一步：客户端像http代理发起CONNECT请求。第二步：http代理接收到CONNECT请求后与abc.com的433端口建立tcp连接。第三步：与abc.com的433端口建立tcp连接成功，通知客户端。 隧道连接示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const http = require('http');const net = require('net');const url = require('url');function request(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end('响应内容');&#125;function connect(req, cltSocket, head) &#123; console.log('TCP连接已完成'); // 连接到原始服务器。 const srvUrl = url.parse(`http://$&#123;req.url&#125;`); const srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () =&gt; &#123; cltSocket.write('HTTP/1.1 200 Connection Established\\r\\n' + 'Proxy-agent: Node.js-Proxy\\r\\n' + '\\r\\n'); srvSocket.write(head); srvSocket.pipe(cltSocket); cltSocket.pipe(srvSocket); &#125;);&#125;// 创建 HTTP 隧道代理。const proxy = http.createServer(request);proxy.on('connect', connect);// 代理正在运行。proxy.listen(8888, '127.0.0.1', () =&gt; &#123; // 向隧道代理发出请求。 const options = &#123; port: 8888, host: '127.0.0.1', method: 'CONNECT', path: 'nodejs.cn:80' &#125;; const req = http.request(options); req.end(); req.on('connect', (res, socket, head) =&gt; &#123; console.log('已连接'); // 通过 HTTP 隧道发出请求。 socket.write('GET / HTTP/1.1\\r\\n' + 'Host: nodejs.cn:80\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n'); socket.on('data', (chunk) =&gt; &#123; console.log(chunk.toString()); &#125;); socket.on('end', () =&gt; &#123; proxy.close(); &#125;); &#125;);&#125;); 解析HTTPS请求明文信息如果我们需要将请求转发到指定目标服务器，那么就需要解析HTTPS的请求报文了。我们都知道SSL的三大功能：内容加密、身份验证和校验机制，校验机制依赖于 MAC（Message authentication code）校验机制，下面主要谈一下身份验证和内容加密。 首先，我们需要支持身份认证，才能建立安全连接，身份认证依赖于证书认证机制。域名证书 是每个支持HTTPS网站都需要有的一份证书，用于客户端验证该网站的安全性，而该证书通常是通过安全机构申请的，这个机构就是 CA（Certificate Authority，证书颁发机构）。在每台用户计算机的操作系统或浏览器中，都会维护一份受信任的CA列表，浏览器在获取到域名证书之后，会向CA根证书进行验证，包含在列表之中的证书，或者由列表中的证书签发的证书都会被客户端信任，如果验证通过则能正常收发请求。 客户端验证服务器证书示意图： 由于代理服务器并没有合法的域名证书（证书只存在真实目标服务器，无法获取到），所以我们需要在代理服务器上伪造证书，实现方案是，node生成根证书，安装并信任，在拦截到https请求时，我们利用根证书动态签发域名证书，并将证书返回给浏览器，浏览器验证证书，由于域名证书是我们信任的根证书签发的，所以会验证通过。 生成根证书：12openssl genrsa -out private.pem 2048openssl req -new -x509 -key private.pem -out public.crt -days 99999 注意运行第二条信息时，需要填写一些证书信息，我们是本地测试，Common Name 可以填写127.0.0.1。然后安装并信任即可（安装信任证书请自行百度） 最后，我们来看下代理服务器如何解析HTTPS请求报文。我们知道，SSL的内容加密功能依赖于密钥协商机制， 报文信息加密解密示意图（简化版）： 1，建立连接时，客户端发起请求；代理拦截后生成域名证书B和私钥b，并用私钥b给证书B签名；同时，代理跟服务器建立连接；服务器用私钥a给证书A签名，并返回给代理；代理将证书B返回给客户端。随后客户端随机生成主密钥M，并用证书B加密，由主密钥生成会话密钥Q；代理拦截后用私钥b解密获得主密钥M，并随机生成主密钥N，用证书A加密发往服务器，并由主密钥生成会话密钥P；服务器解密获得主密钥N。2，完成连接后，客户端用会话密钥Q加密请求；代理拦截后解密获得明文信息，再用会话密钥P加密发往服务器；服务器解密获得明文信息，返回数据； 到此，我们的代理就能解析HTTPS请求的明文信息了，也可以修改信息后发往目标服务器，从而实现HTTPS代理。 最后代理服务器可以实现各种时髦且有用的功能。它们可以改善安全性，提高性能，节省费用。代理服务器可以看到并接触到所有流过的HTTP流量，所以代理服务器可以监视流量并对其进行修改，以实现很多有用的增值Web服务。希望以上的原理介绍可以帮助到大家更好的理解代理服务。","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wangcherry.github.io/blog/tags/node/"},{"name":"http","slug":"http","permalink":"https://wangcherry.github.io/blog/tags/http/"}]},{"title":"barrel文件引起循环依赖","slug":"barrel文件引起循环依赖","date":"2019-04-08T06:07:48.000Z","updated":"2019-12-31T09:21:32.024Z","comments":true,"path":"2019/04/08/barrel文件引起循环依赖/","link":"","permalink":"https://wangcherry.github.io/blog/2019/04/08/barrel文件引起循环依赖/","excerpt":"","text":"在给QDC项目升级时，碰到这样一个报错。server没问题，build时报错 没有报具体错误，按照报错翻译应该是“遇到未定义的provider，通常意味着有一个循环依赖，可能是由于使用“barrel” index.ts 文件引起的”。于是我检查项目中的 provider 使用没有问题，检查了各个模块之间的依赖也没有问题，注意到项目中写了很多index.ts文件，咋一看没有什么问题，比较难发现，但是仔细看index的引用发现barrel使用时有些坑需要注意。 Barrel先介绍一下Barrel，barrel是将多个模块的导出汇总到一个模块的一种方法。barrel本身是一个模块文件，可以重新导出其他模块的选定导出。 例如有三个模块123456789101112131415161718// heroes/hero.component.tsexport class HeroComponent &#123;&#125;// heroes/hero.model.tsexport class Hero &#123;&#125;// heroes/hero.service.tsexport class HeroService &#123;&#125;// index.tsexport * from './hero.model.ts'; // re-export all of its exportsexport * from './hero.service.ts'; // re-export all of its exportsexport &#123; HeroComponent &#125; from './hero.component.ts'; // re-export the named thing// used barrelimport &#123; Hero, HeroService &#125; from '../heroes'; // index is implied// without barrelexport &#123; Hero &#125; from '../heroes/hero.model.ts';export &#123; HeroService &#125; from '../heroes/hero.service.ts'; Barrel的坑在导入同一个模块中的文件时使用barrel可以让文件看起来更清爽，但是在使用时需要注意，因为使用不当可能会引起循环依赖。在这个DQC这个项目中，依赖了@datapi/dscomponent这个包，包在本地打包没问题，但是发成npm包被项目引用后，项目打包就报上面的错误。我简化下，还原报错原因。 目录结构：|—service|—|—a.service.ts|—|—b.service.ts|—|—index.ts|—table|—|—…|—|—table.module.ts 例如如下使用1234567891011121314// a.service.tsexport class AService &#123; &#125;// index.tsexport * from './a.service.ts';export * from './b.service.ts';// table.module.tsimport &#123; AService &#125; from '../service';@NgModule(&#123; ... providers: [AService]&#125;)export class TableModule &#123; &#125; import { AService } from &#39;../service&#39;; 改为 import { AService } from &#39;../service/a.service.ts&#39;; 后问题得到解决 angular风格指南angular团队已经不推荐barrel这种写法，在风格指南已经删除相关写法。 所以删除项目中的barrel，改为具体文件导入。 参考文章Angular DI Error - EXCEPTION: Can’t resolve all parametersBarrel and Circular dependency","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]},{"title":"表格固定表头和固定列","slug":"表格固定表头和固定列","date":"2019-01-12T08:26:52.000Z","updated":"2019-12-31T09:30:30.036Z","comments":true,"path":"2019/01/12/表格固定表头和固定列/","link":"","permalink":"https://wangcherry.github.io/blog/2019/01/12/表格固定表头和固定列/","excerpt":"","text":"平时业务中经常会碰到固定表头或者固定列的需求，对于只固定表头或者固定列的情况可以使用两个表格，利用css实现。但是对于需要同时固定表头和列的情况，就需要四个表格完成样式，js监听滚动事件。如果表格数据比较多，样式复杂，性能就会受影响，效果不是很理想。那么，我们还有其他方式实现同时固定表头和列吗？ 答案是，yes 接下来给大家介绍下 position: sticky; 这个属性 position属性CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。position 常用值有： absolute（生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。） relative（生成相对定位的元素，相对于其正常位置进行定位。） fixed（生成固定定位的元素，相对于浏览器窗口进行定位。） sticky（生成粘性定位元素） 下面我们主要介绍的是粘性定位 粘性定位属性为 position: sticky 的元素是粘性定位元素。 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。举个栗子： git效果图： dt元素在到达顶部之前为相对定位，当元素的top为0之后，就固定在顶部。 查看源码 position: sticky; 实现表格固定表头和列一个表格轻松搞定表头和列固定 gif效果图： 查看源码 需要注意： 该粘性定位元素并不脱离文档流，仍然保留元素原本在文档流中的位置。 当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。 兼容性： 这个属性的兼容性还不是很好，目前仍是一个试验性的属性，并不是W3C推荐的标准。查看兼容性! js实现表格固定表头和列对兼容性要求高时可以考虑用js监听滚动实现固定 gif效果图： ! 查看源码","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wangcherry.github.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://wangcherry.github.io/blog/tags/css/"},{"name":"js","slug":"js","permalink":"https://wangcherry.github.io/blog/tags/js/"}]},{"title":"文件下载和页面打印","slug":"文件下载和页面打印","date":"2018-12-27T05:58:10.000Z","updated":"2019-03-04T07:04:30.190Z","comments":true,"path":"2018/12/27/文件下载和页面打印/","link":"","permalink":"https://wangcherry.github.io/blog/2018/12/27/文件下载和页面打印/","excerpt":"","text":"文件下载和页面打印在业务中有很多使用场景，它们的本质是一样的，都是向后端发一个请求，然后后端返回一个文件。浏览器将文件下载下来，（打印的情况，就是返回html文件，文件加载完之后调浏览器的打印）。 下面主要从文件下载讨论： 使用 a 标签最基础的用法，加 download 属性，浏览器下载该文件。缺点： 不能使用post方法 不能在启动下载时禁用按钮、下载完毕启用按钮1&lt;a href=\"/xhr/doc/ts实践总结&amp;ts解析.pptx\" download&gt;下载&lt;/a&gt; 关于 download 重命名 download 的值可作为文件的名称 后端如果对文件命名，那么会使用后端的命名 在后端没有命名时，以 download 的值为文件名称 都没命名时，或者 download 值设置为空时，下载的文件用文件本身的名称 window.open缺点： 异步回调函数里调 window.open 会被浏览器拦截12345678/** * 下载方法 * @param url * @param target */export const windowOpen = (url: string, target: string = '_blank') =&gt; &#123; window.open(url, target);&#125; 动态创建 a 标签如果在某些业务操作之后再下载的情况，就可以动态创建一个 a 标签。12345678910111213141516/** * 下载方法 * @param url * @param target */export const download = (url: string, target: string = '_blank', fileNmae: string = '') =&gt; &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target; a.download = fileNmae; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a);&#125;; iframe + form 不管是 a 标签还是 window.open ，在异步回调里都可能会被浏览器拦截（具体看浏览器，因为不是用户发起的页面跳转，有些浏览器会认为不安全） 或者是下载请求需要带复杂对象参数，需要用 post 方法，可以使用 iframe + form 利用表单的形式带参数。1234567891011121314151617181920212223242526272829303132333435363738/** * 下载方法 * @param url * @param target */export const download = (url: string, params: any) =&gt; &#123; const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125;&#125;; 使用 fetch 完成下载 对于 post 请求后端直接返回文件流的情况，可以使用 fetch 下载。 更多 Fetch 知识请查看MDN123456789101112/** * 下载方法 * @param url * @param target */ export const downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); ... // 动态创建 a 标签完成 &#125; DEMO源码html：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;p&gt;1：点击 下载 来下载文件：&lt;p&gt;&lt;p&gt;a 标签 &lt;a href=\"/xhr/doc/test.pptx\"&gt;下载&lt;/a&gt;&lt;/p&gt;&lt;p&gt;window.open 下载 &lt;button onclick=\"windowOpen('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;动态创建 a 标签 &lt;button onclick=\"createAEle('/xhr/doc/test.pptx');\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;异步请求回调里下载 &lt;button onclick=\"downloadAfterAsync();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;ajax回调里下载 &lt;button onclick=\"downloadAfterAjax();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;form 表单提交 &lt;button onclick=\"formDownload('/xhr/doc/test.pptx',&#123;a:1,b:2&#125;);\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;p&gt;使用fetch下载 &lt;button onclick=\"downloadByFetch();\"&gt;下载&lt;/button&gt;&lt;/p&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function windowOpen(url) &#123; window.open(url,'_blank'); &#125; function createAEle(url, target, fileName) &#123; const a = document.createElement('a'); a.id = `download$&#123;Date.now()&#125;`; a.href = url; a.target = target || '_target'; a.download = fileName ? fileName : undefined; const body = document.getElementsByTagName('body')[0]; body.appendChild(a); a.click(); body.removeChild(a); &#125;; function downloadAfterAsync() &#123; const http = new XMLHttpRequest(); http.open('GET','/xhr/get/url.json'); http.send(); http.onreadystatechange = () =&gt; &#123; if(http.readyState === 4 &amp;&amp; http.status === 200) &#123; const url = http.responseText; // createAEle(url); // 有些浏览器，动态创建表单也会拦截 // windowOpen(url); // 异步回调里调用，浏览器会拦截 formDownload(url); // 不拦截 &#125; &#125; &#125; function downloadAfterAjax() &#123; $.ajax(&#123; method: 'GET', url: '/xhr/get/url.json', async: false // 将异步改为同步，浏览器不拦截 &#125;).done(url =&gt; &#123; windowOpen(url); &#125;); &#125; function formDownload(url, params) &#123;// 可以使用post方法，携带大对象参数 const body = document.getElementsByTagName('body')[0]; const oldIframe = document.getElementById('perfectIframe'); const oldForm = document.getElementById('perfectForm'); const oldInput = document.getElementById('perfectInput'); if (oldIframe &amp;&amp; oldForm &amp;&amp; oldInput) &#123; oldForm.setAttribute('action', url); oldInput.setAttribute('value', JSON.stringify(params)); document.forms['perfectForm'].submit(); &#125; else &#123; const iframe = document.createElement('iframe'); iframe.setAttribute('name', 'form_target'); iframe.setAttribute('id', 'perfectIframe'); const form = document.createElement('form'); form.setAttribute('id', 'perfectForm'); form.setAttribute('name', 'perfectForm'); form.setAttribute('method', 'post'); form.setAttribute('action', url); form.setAttribute('target', 'form_target'); const hiddenField = document.createElement('input'); hiddenField.setAttribute('id', 'perfectInput'); hiddenField.setAttribute('type', 'hidden'); hiddenField.setAttribute('name', 'value'); hiddenField.setAttribute('value', JSON.stringify(params)); form.appendChild(hiddenField); body.appendChild(form); body.appendChild(iframe); form.submit(); &#125; &#125; async function downloadByFetch() &#123; const res = await fetch('/xhr/doc/test.pptx'); const r = await res.blob(); const blob = new Blob([r], &#123;type: \"application/octet-stream\"&#125;); const url = window.URL.createObjectURL(blob); createAEle(url, '_target', 'a.pptx'); &#125;&lt;/script&gt; server：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const Koa = require('koa');const path = require('path');const fse = require('fse');const static = require('koa-static');const opn = require('opn');const Router = require('koa-router')const bodyParser = require('koa-bodyparser');const app = new Koa();const router = new Router();const returnFile = async (ctx, next) =&gt; &#123; console.log(ctx.request.body);// post 方法提交的参数 let filePath = decodeURI(ctx.path.replace('/xhr/', '')); if (fse.existsSync(path.resolve(filePath))) &#123; ctx.set('Content-disposition', 'attachment; filename=a.pptx'); ctx.set('Content-Type', 'application/vnd.openxmlformats-officedocument.presentationml.presentation; charset=UTF-8'); console.log(path.resolve(filePath)) ctx.body = fse.readFileSync(path.resolve(filePath)); &#125; else &#123; console.log('error'); await next(); &#125;&#125;// 配置静态资源app.use(static( path.join(__dirname, './src')))// 使用ctx.body解析中间件app.use(bodyParser())// 请求router.get('/xhr/doc/:name', returnFile)router.post('/xhr/doc/:name', returnFile)// 请求router.get('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)router.post('/xhr/get/:name', async (ctx, next) =&gt; &#123; ctx.body = '/xhr/doc/test.pptx'&#125;)app .use(router.routes()) .use(router.allowedMethods());opn('http://localhost:3001/');app.listen(3001);","categories":[{"name":"前端","slug":"前端","permalink":"https://wangcherry.github.io/blog/categories/前端/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wangcherry.github.io/blog/tags/typescript/"}]}]}