---
title: 严选工程化实践
date: 2019-12-24 17:30:50
categories:
    - 前端
tags: 
    - node
    - cli
    - 方案设计
---

今年在组里由 angular 技术栈转变成 react 技术栈的大背景下，我们急需一套完善的工程化方案来帮助技术栈落地。在通过确定目标、定义规范、技术调研、开发实现等一系列步骤之后，我们获得一个一套完善的工程化方案。在此做一个记录说明，记录下在实现过程中遇到的问题，希望我的解决思路可以给大家带来一点思考。

## 目录
本文主要从以下四个点分享工程化方案：
- 目标定义
- 方案设计
- 后续计划
- 总结

## 目标定义
作为一个工程化方案，我们最终的目标是尽可能解决项目生命周期里遇到的问题和痛点，例如：

1. 我们团队根据大量的实践经验，总结出一套自己的规范，这一套规范包括项目规范和流程规范，那么这一套规范如何通过我们的工具落地到实际开发中呢？
2. 第二个是我们希望通过大家使用这个工具，完成一个提升开发效率的目标，这个提效包括初始化好一个项目，并且这个项目的dev环境，数据mock，build打包等一系列流程都是完成好的。
3. 第三个目标是解决开发过程中的一个痛点。例如有些资源可以通过封装组件的形式资源共享，但是还有一部分资源大部分情况都还是copy的方式进行复用，例如A、B两个系统有一个相似的列表页，那么这个列表模块复用能不能通过工具完成呢？
4. 第四个目标也是解决一个痛点问题，例如我们资源/项目需要升级了，大多情况是资源开发者出一个升级文档，然后升级的人按照文档一步步修改。这是很重复的一份工作，因为假如你手上有十个项目，你就需要把相同的事情做十遍，那这一步重复的工作我们能不能提到工具里来完成呢？

## 方案设计
基于以上的目标，我们来看一下整个工程化的方案设计。

首先，我们看一下整个方案的架构图：

![](http://mailshark.nos-jd.163yun.com/document/static/4ED8437D499BE0C953BA887896ACD97C.jpg)

### 架构图
我们可以看到整个架构图分为四层：

#### 底层依赖
最底层依赖了规范、webpack、schematics、node，它是上次架构的基石。规范这里包括了项目规范和流程规范，是我们整套方案需要遵守的一些约定；schematics 引入主要是为了解决上面说到的文件处理那块的痛点问题，后面会详细讲到。

#### 插件封装层
这一层主要是对上层需要实现的功能做一个划分，然后通过插件的形式实现。例如：我们将一系列模板做一个抽离，然后这一系列模板在初始化的时候需要做的模板处理放到 init 插件中完成；我们的开发编译阶段需要的 webpack 和server脚本我们就可以放在 @sharkr/scripts 插件中完成；前面说到的资源复用和资源升级问题，我把它叫做文件处理相关的，就抽离在 @sharkr/schematics-cli 插件中完成；还有一部分插件就是比较共用的方法抽离了 util 插件，方便共享；

#### 统一命令层
第三层是统一命令层，这一层做的事情就是，最终对用户暴露一个统一的工具 @sharkr/cli ，在 cli 里去规范我们常用的一些命令，当然这些命令的具体实现都是调的下一层的插件。最后，将这些命令应用到项目开发周期中去。

#### 项目生命周期
项目生命周期，这是我抽象出来的一个概念，就是说我们项目从初始化，到开发（或者是后期迭代），再到CICD的这么一个周期。我们可以看到下一层的命令大多都可以对应到项目生命周期中，例如：
- init 完成项目初始化
- dev 可以使你快速的进入开发
- add 可以给你的项目增加一个资源
- generate 可以执行资源里定义的命令
- update 帮助快速升级资源
- test 对开发过程中的代码做一个测试
- build 在CI阶段可以帮助完成编译打包

通过这整个架构我们可以看到，我们的工具可以介入到项目生命周期里的所有环节，那么这些环节有的一些问题和痛点，我们也可以通过我们的工具去尽量解决。下面我将会从项目生命周期的角度讲解一些我们工程化的一个具体方案。

### 项目初始化
首先，我们项目初始化过程需要解决的一个问题就是：帮助规范落地。

我把规范分为项目规范和流程规范，流程规范我们上面也介绍了，通过我们的工具做了一个约束，那么项目规范怎么在初始化的时候落地呢？

我们的做法是，将这部分规范落地到模板当中，用户通过 @sharkr/cli 去 init 项目，选择合适的模板，完成模板处理，然后就完成了一个项目初始化。

这里我们提到选择合适模板，完成模板处理，这是一个什么东西呢？

#### init 插件
我们每个团队都会有一些常用的业务场景，例如我们B端，会维护好几个模板，纯 web 的、带 node server 的、应用于微应用的，那么这一系列我们作为一个集合，配套的我们会出一个相应的 init 插件，这个插件可以完成我这部分模板的初始化处理。假如说其他团队也有自己的模板，那么同样的，他也可以提供模板配套的 init 插件供 cli 调用。

这是插件的一个好处，可以方便扩展自定义的部分，但是它也带来了一个小问题，例如，这部分插件不是很稳定，可能经常需要更新，它的频繁更新会给用户带来影响。

#### 插件更新
我们先看一下我们最初采用的插件更新机制，如下图：

![](http://mailshark.nos-jd.163yun.com/document/static/4FC4930E8E03B13FA8D8A262B5DC2912.jpg)

1. 用户执行 sr init myapp，调用 @sharkr/cli 
2. @sharkr/cli 检查init插件版本
3. 发现版本不是最新的，提示用户 update @sharkr/cli
4. 用户全局update @sharkr/cli
5. 再次执行 sr init myapp, 调用 @sharkr/cli
6. @sharkr/cli 调用最新的 init 处理

这种方式需要用户经常手动更新，不是很友好，所以在后来方案设计时，改用了采用 npx 的方式调用 init 插件

> npx 是 npm5.2 版本中新增的命令，它能临时下载一个模块并且运行它，运行之后再删除这个模块

![](http://mailshark.nos-jd.163yun.com/document/static/666496AD507AC551D084740F8ECD1991.jpg)

1. 用户执行 sr init myapp，调用 @sharkr/cli 
2. @sharkr/cli 使用 npx 调用最新的 init 插件处理

通过方案二，我们可以看到使用 npx 的方式调用插件，可以使用户在任何时候使用 init 命令都能调用最新的 init 插件完成项目初始化。

说完了项目初始化，我们再来看一下开发/迭代过程中会遇到哪些问题和痛点。

### 开发/迭代
完成项目初始化进入开发阶段，我们遇到的第一个问题就是 dev 环境，例如我们需要 webpack 配置编译代码，需要一个本地 server，需要一个数据转发等，这一部分很好解决，我们通过 @sharkr/scripts 提供 webpack 和 server 脚本，在模板里集成调用，用 koa 起一个本地服务，koa 中间件完成转发等。这个很好解决，反而是前面说到的资源复用和资源/项目升级，我们怎么解决呢。下面我们重点解释一下。

#### 资源复用
我把资源分为两类，一类是有固定输入输出，可抽离的，例如时间控件，下拉列表等；还有一类是无固定输入输出，不可抽离，但是又具有某些共性的，例如B端常见的列表页、详情页，这一部分资源没有一个很好的复用方式。

对于第一类资源，我们可以采用封装组件的形式完成资源共享：

![](http://mailshark.nos-jd.163yun.com/document/static/277820A3C2937B7260B52B5022C95EC5.jpg)

对于第二类资源，我们以前的做法基本是 Ctrl+c、Ctrl+v 来复用，这种做法不够高级，还效率不高，所以我们 cli 提供的第二种做法，那就是将代码模板抽离到一个 schematic 包里，然后通过 @sharkr/cli 来安装这个包，并且执行里面的 schematic。

![](http://mailshark.nos-jd.163yun.com/document/static/A55122BF372983A7BEBA45604145852B.jpg)

#### 资源/项目升级
同样的，假如我们的项目或者是资源需要升级，就需要在项目中升级依赖，可能还需要修改配置、甚至调整目录结构、修改api调用等。这种升级我们以前的做法是，出一份升级文档，升级者按照文档一步步修改项目完成升级。假如有几十个项目，就需要几十个人做相同的事几十遍，这无疑是一个大的人力消耗，我们作为一个提效工具，就是需要将这部分重复的工作通过代码完成。

![](http://mailshark.nos-jd.163yun.com/document/static/8F53EBB061F0D2214458662566A1F85B.jpg)

- 把升级文档里做的事情编写成 schematic 包
- 通过 @sharkr/cli 来安装这个包，并且执行里面的 schematic

这么一看，好像很简单，不管是资源复用，还是项目升级，都写成 schematic 包就好了，那么schematic到底是什么呢？

#### schematics
##### schematics是什么
Schematics 是 @angular-devkit 中的一个功能，可以将变化应用到项目中，总的来说是一个基于模板的支持复杂逻辑的代码生成器。

Schematics 是 Angular 生态系统的一部分，但是它的核心实现都是单独发包的，可以理解为任何的文件处理它都能实现，即使我们的技术栈是 react。

Schematics 执行核心的本质就是在维护一个非常大的 Observable 数据流，这里的数据就是文件树。

[更多schematics知识>>](https://angular.io/guide/schematics)

##### schematics能做什么
schematics 能完成所有基于文件的改动，比如创建一个组件、添加配置项、将框架添加到现有项目，或者更新你的代码来修复更新依赖时带来的 break change。

##### schematics 与 node 脚本的区别
可能有同学看到这里有点疑惑了，我说的 schematics 好像用 node 的脚本写写也能实现。是的，schematics 确实是需要在 node 容器里运行，所以 node 里所有的包它都能结合使用。

但是，schematics 跟单纯的 node 脚本相比，具有两大优势：
- schematics 描述了一个虚拟文件系统
- schematics 内置了很多任务

例如我们要对文件进行修改，使用fs模块，修改直接作用到物理文件，一旦中间某些文件发生错误，再回退修改就比较麻烦了。而 schematics 描述了一个虚拟的文件系统，它包含实际的物理文件目录和修改暂存区两部分，暂存区记录修改，只有当全部确认以后，这些修改才会合并到物理文件上。

schematics 还内置了很多任务，例如你添加了一个模块，需要自己写很多代码，但是 schematics 就提供了 NodePackageInstallTask 直接帮你完成。而且它还会帮你检查依赖的依赖，是不是需要一并安装。还有例如RepositoryInitializerTask git初始化、TslintFixTask tslint处理等内置任务。

schematics 不妨碍你使用 node 包，它只是对文件处理做了增强。

##### schematics 封装
既然 schematics 处理文件很友好，而且刚好能解决我们的问题，于是我们就引入了 schematics 完成文件处理，并对它做了一层封装。

下面我们来看下，开发和使用一个 schematics 包需要做点什么呢？

![](http://mailshark.nos-jd.163yun.com/document/static/0576804849345AE8073F63B4C7D39BD1.jpg)

首先，对于开发者来说，需要做以下三步：

1. 根据 schematics 规范开发一个 schematics 包
2. 定义配置项（可选）
3. 定义 schema 命令

其次，对于用户来说，需要做以下三步：

1. 使用 @sharkr/cli 调用 schematics 包
2. 输入配置（可选）
3. 完成项目修改

那么 @sharkr/cli 做了什么了？

1. @sharkr/cli 调用 @sharkr/schematics 插件
2. schematics 插件解析出自定义配置项，生成用户会话
3. 根据用户会话拿到 option，传入 option 调用 Rule 函数
4. 修改文件放到暂存区
5. 确认修改后更新物理文件

这里 Rule 函数是需要开发者实现的，任何你想写成文档的都能通过代码方式写在这个 Rule 函数里。

##### schematics 实践

下面我们来看一个实际的例子：前段时间我们的项目都需要完成服务上云，为了实现上云，我们需要调整下CI脚本，还要往项目里放一些环境配置文件，涉及到多处文件修改和增加，所以我们写了一个 @sharkr/ng-cloud-add 的 schematics 包达到快速改造项目的目的。以下是效果：

![](http://mailshark.nos-jd.163yun.com/document/static/8FDF86801822A205FA857F680DE70D8D.jpg)

核心代码写起来跟写文档类似：

![](http://mailshark.nos-jd.163yun.com/document/static/191620D84BD0257591D4FDCB48502F09.jpg)

以上就讲完了我们在开发/迭代过程中遇到的问题和解决方案，最后我们再看一下CICD阶段做了什么

### CI
这部分跟 dev 环境类似，也是提供 webpack 配置、build 脚本、还约束了 build 打包后的目录规范。

## 价值与后续计划
### 价值
通过介绍以上的一些方案设计，可以发现这套工具可以让开发更专注业务本身，初始化项目之后就可以直接进入开发；重复的Ctrl+c、Ctrl+v可以通过 schematics 完成，省去重复的人力成本；项目/资源升级可以更加快速推进；规范和文档沉淀到工具中供使用，非常有利于规范的遵守。

### 后续计划
当然，我们目前还存在一些不足，这些不足将在后续的计划中得到完善，例如：

1. 编写 schematics 包需要对 schematics 有一些了解，那么后续我们将会提供包的基础模板和常用方法，让大家开发更便捷。
2. 放在 schematics 包里的资源没有一个很好的展示平台，那么后续我们将会对接正在开发的物料平台，让资源更容易被共享。

## 总结
本篇分享主要从四个方面对工程化实践做了一个阐述：

1. 开发规范的落地依赖模板收敛项目规范，cli 工具收敛流程规范的方式，并在初始化项目时将模板应用于实际项目场景。
2. cli 工具的扩展依赖于插件式，对于自定义的部分提供相应插件即可扩展，而插件的更新依赖npx调用的方式，解决用户需要频繁更新问题。
3. 我们方便快速初始化项目，提供完备的 dev 环境和 build 脚本等提升了我们的开发效率。
4. 资源复用和资源/项目升级统称为文件处理部分，这部分我们是借用了 angular 里的 schematics 功能完成的。在这部分我们还讲了什么是 schematics 以及它在 cli 里做了什么。

以上。